{"version":3,"file":"index.min.js","sources":["../src/library/sound.ts","../src/library/error.ts","../src/library/audio.ts","../src/library/request.ts","../src/library/core.ts"],"sourcesContent":["const SOUND_STATE_STOPPED = 'sound_state_stopped';\nconst SOUND_STATE_PAUSED = 'sound_state_paused';\nconst SOUND_STATE_PLAYING = 'sound_state_playing';\n\nexport type typeSoundStates = typeof SOUND_STATE_STOPPED | typeof SOUND_STATE_PAUSED | typeof SOUND_STATE_PLAYING;\n\nexport interface IOnProgress {\n    (progress: number, maximumValue: number, currentValue: number): void;\n}\n\nexport interface IOnEnded {\n    (willPlayNext: boolean): void;\n}\n\nexport interface IOnAnyAction {\n    (playTimeOffset: number): void;\n}\n\nexport interface ISoundSource {\n    url: string;\n    codec?: string;\n    isPreferred?: boolean;\n}\n\nexport interface ISoundAttributes {\n    // source(s) are NOT mandatory as user can provide an arrayBuffer\n    // and / or audioBuffer in which case the source url is not needed\n    source?: (ISoundSource)[] | ISoundSource;\n    id?: number | string;\n    loop?: boolean;\n    audioBuffer?: AudioBuffer;\n    arrayBuffer?: ArrayBuffer;\n    duration?: number;\n\n    // events\n    onLoading?: IOnProgress;\n    onPlaying?: IOnProgress;\n    onEnded?: IOnEnded;\n    onStarted?: IOnAnyAction;\n    onStopped?: IOnAnyAction;\n    onPaused?: IOnAnyAction;\n    onResumed?: IOnAnyAction;\n}\n\nexport interface ISound extends ISoundAttributes, ISoundSource {\n    sourceNode: AudioBufferSourceNode | MediaElementAudioSourceNode;\n    gainNode: GainNode;\n    isReadyToPLay: boolean;\n    isBuffered: boolean;\n    isBuffering: boolean;\n    audioElement: HTMLAudioElement;\n    audioBufferDate: Date;\n    playTimeOffset: number;\n    startTime: number;\n    playTime: number;\n    playedTimePercentage: number;\n    state: typeSoundStates;\n    loadingProgress: number;\n    firstTimePlayed: boolean;\n    getCurrentTime(): number;\n    getDuration(): number;\n}\n\nexport class PlayerSound implements ISound {\n\n    // static constants\n    static readonly SOUND_STATE_STOPPED = 'sound_state_stopped';\n    static readonly SOUND_STATE_PAUSED = 'sound_state_paused';\n    static readonly SOUND_STATE_PLAYING = 'sound_state_playing';\n\n    // properties\n    public source: (ISoundSource)[] | ISoundSource;\n    public url: string = null;\n    public codec: string = null;\n    public id: number | string;\n    public loop: boolean;\n    public sourceNode: AudioBufferSourceNode | MediaElementAudioSourceNode = null;\n    public gainNode: GainNode = null;\n    public isReadyToPLay = false;\n    public isBuffered = false;\n    public isBuffering = false;\n    public audioElement: HTMLAudioElement = null;\n    public audioBuffer: AudioBuffer = null;\n    public arrayBuffer: ArrayBuffer = null;\n    public audioBufferDate: Date = null;\n    public playTimeOffset = 0;\n    public startTime = 0;\n    public playTime = 0;\n    public playedTimePercentage = 0;\n    public state: typeSoundStates = SOUND_STATE_STOPPED;\n    public loadingProgress = 0;\n    public duration: number = null;\n    public firstTimePlayed = true;\n\n    // callbacks\n    public onLoading: IOnProgress;\n    public onPlaying: IOnProgress;\n    public onEnded: IOnEnded;\n    public onStarted: IOnAnyAction;\n    public onStopped: IOnAnyAction;\n    public onPaused: IOnAnyAction;\n    public onResumed: IOnAnyAction;\n\n    constructor(soundAttributes: ISoundAttributes) {\n\n        // user provided values\n        if (!Array.isArray(soundAttributes.source)) {\n            this.source = [soundAttributes.source];\n        } else {\n            this.source = soundAttributes.source;\n        }\n\n        if (typeof soundAttributes.id !== 'undefined') {\n            this.id = soundAttributes.id;\n        } else {\n            this.id = this._generateSoundId()\n        }\n\n        this.loop = soundAttributes.loop || false;\n\n        // the user can set the duration manually\n        // this is usefull if we need to convert the position percentage into seconds but don't want to preload the song\n        // to get the duration the song has to get preloaded as the duration is a property of the audioBuffer\n        this.duration = soundAttributes.duration || null;\n\n        if (typeof soundAttributes.onLoading === 'function') {\n            this.onLoading = soundAttributes.onLoading;\n        } else {\n            this.onLoading = null;\n        }\n\n        if (typeof soundAttributes.onPlaying === 'function') {\n            this.onPlaying = soundAttributes.onPlaying;\n        } else {\n            this.onPlaying = null;\n        }\n\n        if (typeof soundAttributes.onStarted === 'function') {\n            this.onStarted = soundAttributes.onStarted;\n        } else {\n            this.onStarted = null;\n        }\n\n        if (typeof soundAttributes.onEnded === 'function') {\n            this.onEnded = soundAttributes.onEnded;\n        } else {\n            this.onEnded = null;\n        }\n\n        if (typeof soundAttributes.onStopped === 'function') {\n            this.onStopped = soundAttributes.onStopped;\n        } else {\n            this.onStopped = null;\n        }\n\n        if (typeof soundAttributes.onPaused === 'function') {\n            this.onPaused = soundAttributes.onPaused;\n        } else {\n            this.onPaused = null;\n        }\n\n        if (typeof soundAttributes.onResumed === 'function') {\n            this.onResumed = soundAttributes.onResumed;\n        } else {\n            this.onResumed = null;\n        }\n\n        if (soundAttributes.arrayBuffer instanceof ArrayBuffer) {\n            this.arrayBuffer = soundAttributes.arrayBuffer;\n        }\n\n        if (soundAttributes.audioBuffer instanceof AudioBuffer) {\n            this.audioBuffer = soundAttributes.audioBuffer;\n            this.isBuffering = false;\n            this.isBuffered = true;\n            this.audioBufferDate = new Date();\n            this.duration = this.getDuration();\n        }\n\n    }\n\n    public getCurrentTime(): number {\n\n        let currentTime: number;\n\n        if (this.sourceNode !== null) {\n            if (this.sourceNode instanceof AudioBufferSourceNode) {\n                currentTime = this.sourceNode.context.currentTime;\n            } else if (this.sourceNode instanceof MediaElementAudioSourceNode) {\n                currentTime = this.audioElement.currentTime;\n            }\n        }\n\n        return currentTime;\n\n    }\n\n    public getDuration(): number {\n\n        let duration: number;\n\n        if (this.sourceNode !== null) {\n            if (this.sourceNode instanceof AudioBufferSourceNode) {\n                duration = this.sourceNode.buffer.duration;\n            } else if (this.sourceNode instanceof MediaElementAudioSourceNode) {\n                duration = this.audioElement.duration;\n            }\n        }\n\n        return duration;\n\n    }\n\n    protected _generateSoundId() {\n        return Date.now().toString(36) + Math.random().toString(36).substring(2)\n    }\n\n}\n","ï»¿export interface IPlayerError extends Error {\n    code: number | null;\n}\n\n// https://github.com/Microsoft/TypeScript/issues/12123\nexport class PlayerError extends Error {\n\n    public code: number;\n\n    constructor(message: string, code?: number) {\n\n        super(message);\n\n        this.code = code || null;\n\n        // Set the prototype explictilly\n        Object.setPrototypeOf(this, PlayerError.prototype);\n\n    }\n\n}\n","import { ISound } from './sound';\nimport { PlayerError } from './error';\n\nexport interface IAudioOptions {\n    audioContext: AudioContext;\n    createAudioContextOnFirstUserInteraction: boolean;\n    volume: number;\n    persistVolume: boolean;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/AudioNode\nexport interface IAudioNodes {\n    // https://developer.mozilla.org/en-US/docs/Web/API/GainNode\n    gainNode: GainNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/PannerNode\n    pannerNode?: PannerNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/StereoPannerNode\n    stereoPannerNode?: StereoPannerNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/DelayNode\n    delayNode?: DelayNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ScriptProcessorNode\n    scriptProcessorNode?: ScriptProcessorNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode\n    analyserNode?: AnalyserNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n    biquadFilterNode?: BiquadFilterNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ChannelMergerNode\n    channelMergeNode?: ChannelMergerNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ChannelSplitterNode\n    channelSplitterNode?: ChannelSplitterNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ConvolverNode\n    convolverNode?: ConvolverNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode\n    dynamicCompressorNode?: DynamicsCompressorNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode\n    oscillatorNode?: OscillatorNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/WaveShaperNode\n    waveShaperNode?: WaveShaperNode;\n}\n\ninterface IOnSourceNodeEnded {\n    (event?: Event): void\n}\n\nexport interface IAudioBufferSourceOptions extends AudioBufferSourceOptions {\n    onSourceNodeEnded: IOnSourceNodeEnded;\n}\n\nexport interface IMediaElementAudioSourceOptions extends MediaElementAudioSourceOptions {\n    onSourceNodeEnded: IOnSourceNodeEnded;\n    // add a loop here to match AudioBufferSourceOptions which has a loop\n    loop: boolean;\n}\n\nexport class PlayerAudio {\n\n    protected _options;\n    protected _audioContext: AudioContext = null;\n    protected _volume: number = null;\n    protected _audioNodes: IAudioNodes = {\n        gainNode: null,\n    };\n\n    constructor(options: IAudioOptions) {\n\n        this._options = options;\n\n        this._initialize();\n\n    }\n\n    protected _initialize(): void {\n\n        if (this._options.createAudioContextOnFirstUserInteraction) {\n            this._addAutoCreateAudioContextOnFirstUserInteractionEventListeners();\n        }\n\n    }\n\n    public async decodeAudio(arrayBuffer: ArrayBuffer): Promise<AudioBuffer> {\n\n        const audioContext = await this.getAudioContext();\n\n        // Note to self:\n        // newer decodeAudioData returns promise, older accept as second\n        // and third parameter a success and an error callback funtion\n        // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/decodeAudioData\n\n        const audioBufferPromise = await audioContext.decodeAudioData(arrayBuffer);\n\n        // decodeAudioData returns a promise of type PromiseLike\n        // using resolve to return a promise of type Promise\n        return Promise.resolve(audioBufferPromise);\n\n    }\n\n    protected _createAudioContext(): Promise<void> {\n\n        return new Promise((resolve, reject) => {\n\n            // check if we already have an audio context\n            if (this._audioContext instanceof AudioContext) {\n                // if we do, no need to create a new one\n                resolve();\n            }\n\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const WebAudioContext: typeof AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n\n            // initialize the audio context\n            try {\n                if (this._options.audioContext !== null) {\n                    this._audioContext = this._options.audioContext;\n                } else {\n                    this._audioContext = new WebAudioContext();\n                }\n                resolve();\n            } catch (error) {\n                reject(error);\n            }\n\n        });\n\n    }\n\n    protected _addAutoCreateAudioContextOnFirstUserInteractionEventListeners(): void {\n\n        if (this._options.createAudioContextOnFirstUserInteraction) {\n            document.addEventListener('touchstart', this.getAudioContext.bind(this));\n            document.addEventListener('touchend', this.getAudioContext.bind(this));\n            document.addEventListener('mousedown', this.getAudioContext.bind(this));\n        }\n\n    }\n\n    protected _removeAutoCreateAudioContextOnFirstUserInteractionEventListeners(): void {\n\n        if (this._options.createAudioContextOnFirstUserInteraction) {\n            document.removeEventListener('touchstart', this.getAudioContext.bind(this));\n            document.removeEventListener('touchend', this.getAudioContext.bind(this));\n            document.removeEventListener('mousedown', this.getAudioContext.bind(this));\n        }\n\n    }\n\n    public async getAudioContext(): Promise<AudioContext> {\n\n        if (this._audioContext === null) {\n            await this._createAudioContext();\n        } else if (this._audioContext.state === 'suspended') {\n            await this._unfreezeAudioContext();\n        }\n\n        return this._audioContext;\n\n    }\n\n    protected _unfreezeAudioContext(): Promise<void> {\n\n        // did resume get implemented\n        if (typeof this._audioContext.suspend === 'undefined') {\n\n            // this browser does not support resume\n            // just send back a promise as resume would do\n            return Promise.resolve();\n\n        } else {\n\n            // resume the audio hardware access\n            // audio context resume returns a promise\n            // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/resume\n            return this._audioContext.resume();\n\n        }\n\n    }\n\n    public freezeAudioContext(): Promise<void> {\n\n        // did suspend get implemented\n        if (typeof this._audioContext.suspend === 'undefined') {\n\n            return Promise.resolve();\n\n        } else {\n\n            // halt the audio hardware access temporarily to reduce CPU and battery usage\n            return this._audioContext.suspend();\n\n        }\n\n    }\n\n    public detectAudioContextSupport(): boolean {\n\n        // basic audio context detection\n        let audioContextSupported = false;\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (typeof (window as any).webkitAudioContext !== 'undefined') {\n            audioContextSupported = true;\n        } else if (typeof AudioContext !== 'undefined') {\n            audioContextSupported = true;\n        }\n\n        return audioContextSupported;\n\n    }\n\n    public detectAudioElementSupport(): boolean {\n\n        // basic audio element detection\n        return !!document.createElement('audio').canPlayType;\n\n    }\n\n    public async shutDown(songsQueue: ISound[]): Promise<void> {\n\n        // I know, this is probably the longest function name you have ever seen ;)\n        this._removeAutoCreateAudioContextOnFirstUserInteractionEventListeners();\n\n        // if media element source also destroy the media element? (for each song?)\n        songsQueue.forEach((sound) => {\n            if (sound.sourceNode instanceof MediaElementAudioSourceNode) {\n                if (typeof sound.sourceNode.mediaElement !== 'undefined') {\n                    sound.sourceNode.mediaElement.remove();\n                }\n            }\n            sound.sourceNode.disconnect();\n        });\n\n        this._disconnectPlayerGainNode();\n\n        await this._destroyAudioContext();\n\n    }\n\n    protected async _destroyAudioContext(): Promise<void> {\n\n        if (this._audioContext !== null) {\n            await this._audioContext.close();\n            this._audioContext = null;\n        }\n\n    }\n\n    public async createAudioBufferSourceNode(audioBufferSourceOptions: IAudioBufferSourceOptions, sound: ISound): Promise<void> {\n\n        const audioContext = await this.getAudioContext();\n\n        const audioBufferSourceNode: AudioBufferSourceNode = audioContext.createBufferSource();\n\n        sound.sourceNode = audioBufferSourceNode;\n\n        // do we loop this song\n        audioBufferSourceNode.loop = audioBufferSourceOptions.loop;\n\n        // create the sound gain node\n        sound.gainNode = audioBufferSourceNode.context.createGain();\n\n        // set the gain by default always to 1\n        // TODO: allow user to define a gain value for each sound via sound options\n        // TODO: future allow a sound gain to be faded out at end\n        // (faded in at start) without changing the main player gain\n        sound.gainNode.gain.value = 1;\n\n        // connect the source to the sound gain node\n        audioBufferSourceNode.connect(sound.gainNode);\n\n        // if the song ends destroy it's audioGraph as the source can't be reused anyway\n        // NOTE: the source nodes onended handler won't have any effect if the loop property is set to\n        // true, as the audio won't stop playing. To see the effect in this case you'd\n        // have to use AudioBufferSourceNode.stop()\n        audioBufferSourceNode.onended = (event: Event): void => {\n            audioBufferSourceOptions.onSourceNodeEnded(event);\n        };\n\n    }\n\n    public async createMediaElementSourceNode(sourceNodeOptions: IMediaElementAudioSourceOptions, sound: ISound): Promise<void> {\n\n        let mediaElementAudioSourceNode: MediaElementAudioSourceNode;\n\n        if (sound.sourceNode === null) {\n\n            const audioContext = await this.getAudioContext();\n\n            try {\n                // createMediaElementSource: https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createMediaElementSource\n                mediaElementAudioSourceNode = audioContext.createMediaElementSource(sourceNodeOptions.mediaElement) as MediaElementAudioSourceNode;\n            } catch (error) {\n                throw new PlayerError(error);\n            }\n\n            // do we loop this song\n            mediaElementAudioSourceNode.mediaElement.loop = sourceNodeOptions.loop;\n\n            // create the sound gain node\n            sound.gainNode = mediaElementAudioSourceNode.context.createGain();\n\n            sound.gainNode.gain.value = 1;\n\n            // connect the source to the sound gain node\n            mediaElementAudioSourceNode.connect(sound.gainNode);\n\n            // MediaElementSource: https://developer.mozilla.org/en-US/docs/Web/API/MediaElementAudioSourceNode/mediaElement\n\n            // NOTE: the source nodes onended handler won't have any effect if the loop property is set to\n            // true, as the audio won't stop playing. To see the effect in this case you'd\n            // have to use AudioBufferSourceNode.stop()\n            mediaElementAudioSourceNode.mediaElement.onended = async (): Promise<void> => {\n                sourceNodeOptions.onSourceNodeEnded();\n            };\n\n            sound.sourceNode = mediaElementAudioSourceNode;\n\n        }\n\n    }\n\n    protected async _getPlayerGainNode(): Promise<GainNode> {\n\n        // the player (master) gain node\n        let gainNode: GainNode;\n\n        if (this._audioNodes.gainNode instanceof GainNode) {\n\n            gainNode = this._audioNodes.gainNode;\n\n        } else {\n\n            const audioContext = await this.getAudioContext();\n\n            // Note: a volume control (GainNode) should always\n            // be the last node that gets connected\n            // so that volume changes take immediate effect\n            gainNode = audioContext.createGain();\n\n            // final step: connect the gain node to the audio destination node\n            gainNode.connect(audioContext.destination);\n\n            this._audioNodes.gainNode = gainNode;\n\n        }\n\n        this._initializeVolume()\n\n        return gainNode;\n\n    }\n\n    protected _disconnectPlayerGainNode(): void {\n\n        this._audioNodes.gainNode.disconnect();\n\n        this._audioNodes.gainNode = null;\n\n    }\n\n    public async connectSound(sound: ISound): Promise<void> {\n\n        const playerGainNode = await this._getPlayerGainNode();\n        const soundGainNode = sound.gainNode;\n\n        if (soundGainNode !== null) {\n            soundGainNode.connect(playerGainNode);\n        }\n\n    }\n\n    public async disconnectSound(sound: ISound): Promise<void> {\n\n        if (sound.gainNode !== null) {\n            //sound.gainNode.disconnect();\n        } else {\n            throw new PlayerError('can\\'t destroy as no source node in sound');\n        }\n\n        if (sound.sourceNode instanceof AudioBufferSourceNode) {\n            // the audio buffer source node we set it to undefined, to let it get destroyed\n            // by the garbage collector as you can't reuse an audio buffer source node\n            // (after it got stopped) as specified in the specs\n            sound.sourceNode = null;\n        }\n\n    }\n\n    protected _changePlayerGainValue(gainValue: number): void {\n\n        if (this._audioNodes.gainNode instanceof GainNode) {\n            this._audioNodes.gainNode.gain.value = gainValue;\n        }\n\n    }\n\n    protected _roundGainTwoDecimals(rawGainValue: number): number {\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n        return Math.round((rawGainValue + Number.EPSILON) * 100) / 100\n\n    }\n\n    public setVolume(volume: number, forceUpdateUserVolume = true) {\n\n        // we sometimes change the volume, for a fade in/out or when muting, but\n        // in this cases we don't want to update the user's persisted volume, in\n        // which case forceUpdateUserVolume is false else it would be true\n        if (this._options.persistVolume && forceUpdateUserVolume) {\n            localStorage.setItem('WebAudioAPIPlayerVolume', volume.toString());\n        }\n\n        // the gain values we use range from 0 to 1\n        // so we need to divide the volume (in percent) by 100 to get the gain value\n        const gainValue = volume / 100;\n\n        if (this._audioNodes.gainNode instanceof GainNode) {\n\n            const roundedGain = this._roundGainTwoDecimals(this._audioNodes.gainNode.gain.value)\n\n            // check if the volume changed\n            if (roundedGain !== this._volume) {\n\n                // the gain value changes the amplitude of the sound wave\n                // a gain value of one does nothing\n                // values between 0 and 1 reduce the loudness, above one they amplify the loudness\n                // negative values work too, but they invert the waveform, so -1 is as loud as 1\n                this._changePlayerGainValue(gainValue);\n\n            }\n\n        }\n\n        this._volume = volume;\n\n    }\n\n    public getVolume(): number {\n\n        let volume: number\n\n        // check if volume has already been set\n        if (this._volume !== null) {\n            volume = this._volume\n        } else {\n            if (this._options.persistVolume) {\n                // if persist volume is enabled, check if there is a user volume in localstorage\n                const userVolumeInPercent = parseInt(localStorage.getItem('WebAudioAPIPlayerVolume'));\n    \n                if (!isNaN(userVolumeInPercent)) {\n                    volume = userVolumeInPercent\n                }\n            }\n\n            // if volume is not persisted or persited value not yet set\n            if (typeof volume === 'undefined') {\n                volume = this._options.volume\n            }\n        }\n\n        return volume\n\n    }\n\n    protected _initializeVolume(): void {\n\n        if (this._options.persistVolume) {\n            // if persist volume is enabled, check if there is a user volume in localstorage\n            const userVolumeInPercent = parseInt(localStorage.getItem('WebAudioAPIPlayerVolume'));\n\n            if (!isNaN(userVolumeInPercent)) {\n                this.setVolume(userVolumeInPercent, false);\n            }\n        }\n\n        // if no user volume take the default options volume\n        if (this._volume === null) {\n            this.setVolume(this._options.volume, false);\n        }\n\n    }\n\n}\n","import { PlayerError } from './error';\nimport { IOnProgress } from './sound';\n\nexport interface IRequested {\n    url: string;\n    loadingProgress: number;\n    onLoading?: IOnProgress;\n}\n\nexport class PlayerRequest {\n\n    // TODO: add possibility to abort http request\n\n    public getArrayBuffer(requested: IRequested): Promise<ArrayBuffer> {\n\n        return new Promise(function (resolve, reject) {\n\n            const xhr = new XMLHttpRequest();\n\n            // TODO: abort the request?\n            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/abort\n\n            // thirs parameter is for \"async\", default true but who knows if prefer to explicitly set it just in case\n            xhr.open('GET', requested.url, true);\n\n            // set the expected response type from the server to arraybuffer\n            xhr.responseType = 'arraybuffer';\n\n            xhr.onload = function (): void {\n\n                // gets called even on for example 404, so check the status\n                if (xhr.status === 200) {\n\n                    // successful request so now we can resolve the promise\n                    resolve(xhr.response);\n\n                } else {\n\n                    // something went wrong so we reject with an error\n                    reject(new PlayerError(xhr.statusText, xhr.status));\n\n                }\n\n            };\n\n            xhr.onprogress = function (event): void {\n\n                const percentage = 100 / (event.total / event.loaded);\n\n                // update value on sound object\n                requested.loadingProgress = percentage;\n\n                if (requested.onLoading !== null) {\n                    requested.onLoading(percentage, event.total, event.loaded);\n                }\n\n            };\n\n            // also reject for any kind of network errors\n            xhr.onerror = function (): void {\n\n                reject(new PlayerError('xhr network error'));\n\n            };\n\n            // now make the request\n            xhr.send();\n\n        });\n\n    }\n\n}\n","import { PlayerSound, ISound, ISoundAttributes, ISoundSource, typeSoundStates } from './sound';\nimport {\n    PlayerAudio,\n    IAudioOptions,\n    IAudioBufferSourceOptions,\n    IMediaElementAudioSourceOptions,\n} from './audio';\nimport { PlayerRequest } from './request';\nimport { PlayerError, IPlayerError } from './error';\n\nconst PLAYER_MODE_AUDIO = 'player_mode_audio';\nconst PLAYER_MODE_AJAX = 'player_mode_ajax';\nconst PLAYER_MODE_FETCH = 'player_mode_fetch';\n\nconst WHERE_IN_QUEUE_AT_START = 'prepend';\nconst WHERE_IN_QUEUE_AT_END = 'append';\n\ntype typePlayerMode = typeof PLAYER_MODE_AUDIO | typeof PLAYER_MODE_AJAX | typeof PLAYER_MODE_FETCH;\ntype typeWhereInQueue = typeof WHERE_IN_QUEUE_AT_START | typeof WHERE_IN_QUEUE_AT_END;\n\nexport interface ICoreOptions {\n    volume?: number;\n    loopQueue?: boolean;\n    loopSong?: boolean;\n    soundsBaseUrl?: string;\n    playingProgressIntervalTime?: number;\n    playNextOnEnded?: boolean;\n    stopOnReset?: boolean;\n    visibilityAutoMute?: boolean;\n    createAudioContextOnFirstUserInteraction?: boolean;\n    persistVolume?: boolean;\n    loadPlayerMode?: typePlayerMode;\n    audioContext?: AudioContext;\n}\n\nexport interface ISoundsQueueOptions {\n    soundAttributes: ISoundAttributes;\n    whereInQueue?: typeWhereInQueue;\n}\n\ninterface IDecodeSoundOptions {\n    sound: ISound;\n}\n\nexport interface IPlayOptions {\n    whichSound?: number | string | undefined;\n    playTimeOffset?: number;\n}\n\ninterface IFindSoundById {\n    soundId: string | number;\n}\n\ninterface IFindBestSourceResponse {\n    url: string;\n    codec?: string;\n}\n\ninterface IGetSoundFromQueue {\n    whichSound?: string | number;\n    updateIndex?: boolean;\n}\n\ninterface IBestSource {\n    url: string;\n    codec?: string;\n}\n\nexport class PlayerCore {\n\n    // the sounds queue\n    protected _queue: ISound[];\n    // the current sound in queue index\n    protected _currentIndex: number;\n    // instance of the audio library class\n    protected _playerAudio: PlayerAudio;\n    // playing progress animation frame request id\n    protected _playingProgressRequestId: number = null;\n    // playing progress animation frame previous timestamp\n    protected _playingProgressPreviousTimestamp: DOMHighResTimeStamp = 0;\n    // value of the volume before we muted\n    protected _postMuteVolume: number\n    // user player options\n    protected _options: ICoreOptions;\n\n    // constants\n    static readonly WHERE_IN_QUEUE_AT_END = 'append';\n    static readonly WHERE_IN_QUEUE_AT_START = 'prepend';\n\n    static readonly PLAY_SOUND_NEXT = 'next';\n    static readonly PLAY_SOUND_PREVIOUS = 'previous';\n    static readonly PLAY_SOUND_FIRST = 'first';\n    static readonly PLAY_SOUND_LAST = 'last';\n\n    static readonly CURRENT_SOUND = 'current';\n\n    static readonly PLAYER_MODE_AUDIO = 'player_mode_audio';\n    static readonly PLAYER_MODE_AJAX = 'player_mode_ajax';\n    static readonly PLAYER_MODE_FETCH = 'player_mode_fetch';\n\n    constructor(playerOptions: ICoreOptions = {}) {\n\n        const defaultOptions: ICoreOptions = {\n            volume: 80,\n            loopQueue: false,\n            loopSong: false,\n            soundsBaseUrl: '',\n            playingProgressIntervalTime: 200,\n            playNextOnEnded: true,\n            stopOnReset: true,\n            visibilityAutoMute: false,\n            createAudioContextOnFirstUserInteraction: true,\n            persistVolume: true,\n            loadPlayerMode: PLAYER_MODE_AUDIO,\n            audioContext: null,\n        };\n\n        const options = Object.assign({}, defaultOptions, playerOptions);\n\n        this._queue = [];\n        this._currentIndex = null;\n        this._options = options;\n\n        this._initialize();\n\n    }\n\n    protected _initialize(): void {\n\n        const audioOptions = this._audioOptions();\n\n        // player audio library instance\n        this._playerAudio = new PlayerAudio(audioOptions);\n\n        switch (this._options.loadPlayerMode) {\n            case PlayerCore.PLAYER_MODE_AUDIO:\n                if (!this._playerAudio.detectAudioContextSupport()) {\n                    throw new PlayerError('audio context is not supported by this device');\n                }\n                if (!this._playerAudio.detectAudioElementSupport()) {\n                    throw new PlayerError('audio element is not supported by this device');\n                }\n                break;\n            case PlayerCore.PLAYER_MODE_AJAX:\n                if (!this._playerAudio.detectAudioContextSupport()) {\n                    throw new PlayerError('audio context is not supported by this device');\n                }\n                break;\n        }\n\n    }\n\n    protected _audioOptions(): IAudioOptions {\n\n        const audioOptions: IAudioOptions = {\n            audioContext: this._options.audioContext,\n            createAudioContextOnFirstUserInteraction: this._options.createAudioContextOnFirstUserInteraction,\n            volume: this._options.volume,\n            persistVolume: this._options.persistVolume,\n        };\n\n        return audioOptions;\n\n    }\n\n    public addSoundToQueue({ soundAttributes, whereInQueue = WHERE_IN_QUEUE_AT_END }: ISoundsQueueOptions): ISound {\n\n        const sound: ISound = new PlayerSound(soundAttributes);\n\n        switch (whereInQueue) {\n            case PlayerCore.WHERE_IN_QUEUE_AT_END:\n                this._appendSoundToQueue(sound);\n                break;\n            case PlayerCore.WHERE_IN_QUEUE_AT_START:\n                this._prependSoundToQueue(sound);\n                break;\n        }\n\n        return sound;\n\n    }\n\n    public _appendSoundToQueue(sound: ISound): void {\n\n        this._queue.push(sound);\n\n    }\n\n    public _prependSoundToQueue(sound: ISound): void {\n\n        this._queue.unshift(sound);\n\n    }\n\n    public resetQueue(): void {\n\n        // check if sound should be stopped on reset\n        if (this._options.stopOnReset) {\n            this.stop();\n        }\n\n        // TODO: destroy all the sounds or clear the cached buffers manually\n        // or will garbage collector do it?\n\n        this._queue = [];\n\n    }\n\n    public reset(): void {\n\n        this.resetQueue();\n\n    }\n\n    public getQueue(): ISound[] {\n        \n        return this._queue;\n\n    }\n\n    public setVolume(volume: number): void {\n\n        this._playerAudio.setVolume(volume)\n\n    }\n\n    public getVolume(): number {\n\n        return this._playerAudio.getVolume();\n\n    }\n\n    public setLoopQueue(loppQueue: boolean): void {\n\n        this._options.loopQueue = loppQueue;\n\n    }\n\n    public getLoopQueue(): boolean {\n\n        return this._options.loopQueue;\n\n    }\n\n    public mute(): void {\n\n        const currentVolume = this.getVolume();\n\n        this._postMuteVolume = currentVolume;\n\n        this._playerAudio.setVolume(0, false);\n\n    }\n\n    public unMute(): void {\n\n        this._playerAudio.setVolume(this._postMuteVolume, false);\n\n        this._postMuteVolume = null;\n\n    }\n\n    public isMuted(): boolean {\n\n        return this._postMuteVolume === null ? true : false;\n\n    }\n\n    public setPosition(soundPositionInPercent: number): void {\n\n        // get the current sound if any\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        // if there is a sound currently being played\n        if (currentSound !== null) {\n\n            // if the duration did not get set manually\n            if (currentSound.duration === null || isNaN(currentSound.duration)) {\n\n                // the user can set the sound duration manually but if he didn't the sound has to\n                // get loaded as the duration is a property of the audioBuffer\n                this._loadSound(currentSound)\n                    .then((sound: ISound) => {\n\n                        // calculate the position in seconds\n                        const soundPositionInSeconds = (sound.duration / 100) * soundPositionInPercent;\n\n                        this.setPositionInSeconds(soundPositionInSeconds);\n\n                    }).catch((error: PlayerError) => {\n\n                        throw error;\n\n                    });\n\n            } else {\n\n                // calculate the position in seconds\n                const soundPositionInSeconds = (currentSound.duration / 100) * soundPositionInPercent;\n\n                this.setPositionInSeconds(soundPositionInSeconds);\n\n            }\n\n        }\n\n    }\n\n    public setPositionInSeconds(soundPositionInSeconds: number): void {\n\n        // get the current sound if any\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        // if there is a sound currently being played\n        if (currentSound !== null) {\n\n            // is the sound is being played\n            if (currentSound.state === PlayerSound.SOUND_STATE_PLAYING) {\n                // resume the playback at the given position\n                this.play({ whichSound: currentSound.id, playTimeOffset: soundPositionInSeconds });\n            } else {\n                // only set the sound position but don't play\n                currentSound.playTimeOffset = soundPositionInSeconds;\n            }\n\n        } else {\n\n            throw new PlayerError('position change called, but no current sound found');\n\n        }\n\n    }\n\n    protected _loadSound(sound: ISound): Promise<ISound | PlayerError> {\n\n        let loadSoundPromise;\n        let notImplementedError;\n\n        switch (this._options.loadPlayerMode) {\n            case PlayerCore.PLAYER_MODE_AUDIO:\n                loadSoundPromise = this._loadSoundUsingAudioElement(sound);\n                break;\n            case PlayerCore.PLAYER_MODE_AJAX:\n                loadSoundPromise = this._loadSoundUsingRequest(sound);\n                break;\n            case PlayerCore.PLAYER_MODE_FETCH:\n\n                // TODO: implement fetch\n\n                notImplementedError = new PlayerError(PlayerCore.PLAYER_MODE_FETCH + ' is not implemented yet', 1);\n\n                loadSoundPromise = Promise.reject(notImplementedError);\n\n                break;\n        }\n\n        return loadSoundPromise;\n\n    }\n\n    protected _loadSoundUsingAudioElement(sound: ISound): Promise<ISound | PlayerError> {\n\n        return new Promise((resolve, reject) => {\n\n            // if the audio element has already been created\n            // we are ready to play\n            /*if (sound.audioElement !== null) {\n                sound.isReadyToPLay = true;\n                resolve(sound);\n            }*/\n\n            // extract the url and codec from sources\n            const { url, codec = null } = this._findBestSource(sound.source);\n\n            sound.url = url;\n            sound.codec = codec;\n            sound.arrayBuffer = null;\n\n            if (sound.url !== null) {\n\n                const audioElement = new Audio();\n\n                // in chrome you will get this error message in the console:\n                // \"MediaElementAudioSource outputs zeroes due to CORS access restrictions\"\n                // to fix this put crossOrigin to anonymous or change the cors\n                // Access-Control-Allow-Origin header of the server to *\n                // \"crossOrigin\" has to be set before \"src\"\n                audioElement.crossOrigin = 'anonymous';\n\n                audioElement.src = sound.url;\n                audioElement.controls = false;\n                audioElement.autoplay = false;\n                audioElement.id = 'web_audio_api_player_sound_' + sound.id.toString();\n\n                document.body.appendChild(audioElement);\n\n                sound.audioElement = audioElement;\n                sound.isReadyToPLay = true;\n\n                this._initializeAudioElementListeners(sound);\n\n                const canplaythroughListener = () => {\n                    // we don't need the listener anymore\n                    sound.audioElement.removeEventListener('canplaythrough', canplaythroughListener);\n                    // duration should now be available as the sound has been fully loaded\n                    if (!isNaN(audioElement.duration)) {\n                        sound.duration = audioElement.duration;\n                    }\n                    resolve(sound);\n                };\n\n                sound.audioElement.addEventListener('canplaythrough', canplaythroughListener);\n\n                const errorListener = () => {\n                    sound.audioElement.removeEventListener('error', errorListener);\n                    const soundLoadingError = new PlayerError('loading sound failed');\n                    reject(soundLoadingError);\n                };\n\n                sound.audioElement.addEventListener('error', errorListener);\n\n            } else {\n\n                const noUrlError = new PlayerError('sound has no url', 1);\n\n                reject(noUrlError);\n\n            }\n\n        });\n\n    }\n\n    protected _loadSoundUsingRequest(sound: ISound): Promise<ISound | PlayerError> {\n\n        return new Promise((resolve, reject) => {\n\n            // extract the url and codec from sources\n            const { url, codec = null } = this._findBestSource(sound.source);\n\n            sound.url = url;\n            sound.codec = codec;\n\n            if (sound.url !== null) {\n\n                const request = new PlayerRequest();\n\n                // change buffering state\n                sound.isBuffering = true;\n\n                request.getArrayBuffer(sound).then((arrayBuffer) => {\n\n                    sound.arrayBuffer = arrayBuffer;\n\n                    this._decodeSound({ sound }).then((sound: ISound) => {\n                        resolve(sound);\n                    }).catch(reject)\n\n                }).catch((requestError) => {\n\n                    reject(requestError);\n\n                });\n\n            } else {\n\n                const noUrlError = new PlayerError('sound has no url', 1);\n\n                reject(noUrlError);\n\n            }\n\n        });\n\n    }\n\n    protected _initializeAudioElementListeners(sound: ISound): void {\n\n        sound.audioElement.addEventListener('progress', () => {\n            sound.loadingProgress = sound.audioElement.duration;\n        });\n\n        sound.audioElement.addEventListener('timeupdate', () => {\n            sound.duration = sound.audioElement.duration;\n        });\n\n    }\n\n    protected _decodeSound({ sound }: IDecodeSoundOptions): Promise<ISound> {\n\n        return this._playerAudio.decodeAudio(sound.arrayBuffer).then((audioBuffer) => {\n\n            sound.audioBuffer = audioBuffer;\n            sound.isBuffering = false;\n            sound.isBuffered = true;\n            sound.audioBufferDate = new Date();\n            sound.duration = audioBuffer.duration;\n            sound.isReadyToPLay = true;\n\n            return sound;\n\n        }).catch((decodeAudioError: IPlayerError) => {\n\n            throw decodeAudioError;\n\n        });\n\n    }\n\n    // source: https://stackoverflow.com/questions/43655953/web-audio-api-cloning-an-audiobuffer\n    protected _cloneAudioBuffer(fromAudioBuffer: AudioBuffer) {\n        const audioBuffer = new AudioBuffer({\n            length: fromAudioBuffer.length,\n            numberOfChannels: fromAudioBuffer.numberOfChannels,\n            sampleRate: fromAudioBuffer.sampleRate\n        });\n        for (let channelI = 0; channelI < audioBuffer.numberOfChannels; ++channelI) {\n            const samples = fromAudioBuffer.getChannelData(channelI);\n            audioBuffer.copyToChannel(samples, channelI);\n        }\n        return audioBuffer;\n    }\n\n    public play({ whichSound, playTimeOffset }: IPlayOptions = {}): Promise<void> {\n\n        return new Promise((resolve, reject) => {\n\n            // get the current sound if any\n            const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n            // whichSound is optional, if set it can be the sound id or if it's a string it can be next / previous / first / last\n            const sound = this._getSoundFromQueue({ whichSound, updateIndex: true });\n\n            // if there is no sound we could play, do nothing\n            if (sound === null) {\n                throw new Error('no more sounds in array');\n            }\n\n            // if there is a sound currently being played OR paused\n            // AND the current sound is NOT the same sound as the one that will now be played\n            // STOP the current sound\n            if (\n                currentSound !== null\n                && (currentSound.state === PlayerSound.SOUND_STATE_PLAYING || currentSound.state === PlayerSound.SOUND_STATE_PAUSED)\n                && (currentSound.id !== sound.id)\n            ) {\n                this._stop(currentSound, PlayerSound.SOUND_STATE_STOPPED);\n            }\n\n            // if there is a sound currently being played\n            // AND the current sound is the same sound as the one that will now be played\n            // PAUSE the current sound\n            if (\n                currentSound !== null\n                && (currentSound.state === PlayerSound.SOUND_STATE_PLAYING)\n                && (currentSound.id === sound.id)\n            ) {\n                this._stop(currentSound, PlayerSound.SOUND_STATE_PAUSED);\n            }\n\n            // if the current sound and the next one are not the same sound\n            // we set the firstTimePlayed to true to indicate it is a fresh start and not a resume after a pause\n            if (currentSound === null || (currentSound !== null && (currentSound.id !== sound.id))) {\n                sound.firstTimePlayed = true;\n            } else {\n                sound.firstTimePlayed = false;\n            }\n\n            // if the user wants to play the sound from a certain position\n            if (playTimeOffset !== undefined) {\n                sound.playTimeOffset = playTimeOffset;\n            }\n\n            // has the sound already been loaded?\n            if (!sound.isReadyToPLay) {\n\n                this._loadSound(sound).then(() => {\n\n                    this._play(sound).then(resolve).catch(reject);\n\n                }).catch(reject);\n\n            } else {\n\n                // avoid refetching the sound (getting the array buffer)\n                // by using a clone we avoid having to do the decoding again\n                if (sound.audioBuffer !== null) {\n                    sound.audioBuffer = this._cloneAudioBuffer(sound.audioBuffer)\n                }\n\n                this._play(sound).then(resolve).catch(reject);\n\n            }\n\n        });\n\n    }\n\n    protected async _play(sound: ISound): Promise<void> {\n\n        // start playing\n        if (sound.audioBuffer !== null) {\n            await this._playAudioBuffer(sound);\n        } else {\n            await this._playMediaElementAudio(sound);\n        }\n\n        // state is now playing\n        sound.state = PlayerSound.SOUND_STATE_PLAYING;\n\n        // the audio context time right now (since the audiocontext got created)\n        sound.startTime = sound.getCurrentTime();\n\n        sound = this._triggerSoundCallbacks(sound);\n\n    }\n\n    protected async _playAudioBuffer(sound: ISound): Promise<void> {\n\n        if (sound.sourceNode === null) {\n\n            // source node options\n            const sourceOptions: IAudioBufferSourceOptions = {\n                loop: sound.loop,\n                onSourceNodeEnded: (/*event: Event*/) => {\n                    this._onEnded()\n                }\n            };\n\n            try {\n                await this._playerAudio.createAudioBufferSourceNode(sourceOptions, sound);\n            } catch (error) {\n                throw new PlayerError(error);\n            }\n\n        }\n\n        // AudioBufferSourceNode type guard\n        if (sound.sourceNode instanceof AudioBufferSourceNode) {\n\n            // add the buffer to the source node\n            sound.sourceNode.buffer = sound.audioBuffer;\n\n            // connect the source to the graph node(s)\n            await this._playerAudio.connectSound(sound);\n\n            // start playback\n            // start(when, offset, duration)\n            try {\n                if (sound.playTimeOffset !== undefined) {\n                    sound.sourceNode.start(0, sound.playTimeOffset);\n                } else {\n                    sound.sourceNode.start();\n                }\n            } catch (error) {\n                throw new PlayerError(error);\n            }\n        }\n\n    }\n\n    protected async _playMediaElementAudio(sound: ISound): Promise<void> {\n\n        if (sound.sourceNode === null) {\n\n            // source node options\n            const sourceOptions: IMediaElementAudioSourceOptions = {\n                loop: sound.loop,\n                onSourceNodeEnded: (/**event: Event*/) => {\n                    this._onEnded()\n                },\n                mediaElement: sound.audioElement\n            };\n\n            // create an media element audio source node\n            try {\n                await this._playerAudio.createMediaElementSourceNode(sourceOptions, sound);\n            } catch (error) {\n                throw new PlayerError(error);\n            }\n\n        }\n\n        // MediaElementAudioSourceNode type guard\n        if (sound.sourceNode instanceof MediaElementAudioSourceNode) {\n\n            // connect the source to the graph node(s)\n            await this._playerAudio.connectSound(sound);\n\n            // if an offset is defined use to play from a defined position\n            if (sound.playTimeOffset !== undefined && !isNaN(sound.playTimeOffset)) {\n\n                // TODO: problem if sound has not loaded until for example 90% but position gets set to 90%\n                // the position will jump back\n                // need to wait for sound to have loaded that part, use events???\n\n                sound.audioElement.currentTime = sound.playTimeOffset;\n            }\n\n            try {\n                sound.sourceNode.mediaElement.play();\n            } catch (error) {\n                throw new PlayerError(error);\n            }\n\n        }\n\n    }\n\n    protected _triggerSoundCallbacks(sound: ISound): ISound {\n\n        // if there is an onResumed callback for the sound, trigger it\n        if (sound.onResumed !== null && !sound.firstTimePlayed) {\n            sound.onResumed(sound.playTimeOffset);\n        }\n\n        // if there is an onStarted callback for the sound, trigger it\n        if (sound.onStarted !== null && sound.firstTimePlayed) {\n            sound.onStarted(sound.playTimeOffset);\n        }\n\n        // if there is an onPlaying callback for the sound, trigger it\n        if (sound.onPlaying !== null) {\n            // on request animation frame callback set playing progress\n            // request animation frame callback has a argument, which\n            // is the timestamp when the callback gets called\n            this._playingProgressRequestId = window.requestAnimationFrame((timestamp) => {\n                this._progressTrigger(sound, timestamp)\n            });\n        } else {\n            this._playingProgressRequestId = null;\n        }\n\n        return sound;\n\n    }\n\n    protected _progressTrigger = (sound: ISound, timestamp: DOMHighResTimeStamp) => {\n        // throttle requests to not more than once every 200ms \n        if ((timestamp - this._playingProgressPreviousTimestamp) >= this._options.playingProgressIntervalTime) {\n            // execute playing progress callback\n            this._playingProgress(sound);\n            this._playingProgressPreviousTimestamp = timestamp;\n        }\n        // request animation frame loop\n        this._playingProgressRequestId = window.requestAnimationFrame((timestamp) => {\n            this._progressTrigger(sound, timestamp);\n        });\n    };\n\n    protected _onEnded(): void {\n\n        // get the current sound if any\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        // if there is a sound currently being played\n        if (currentSound !== null && currentSound.state === PlayerSound.SOUND_STATE_PLAYING) {\n\n            const nextSound = this._getSoundFromQueue({ whichSound: PlayerCore.PLAY_SOUND_NEXT, updateIndex: false });\n\n            if (currentSound.onEnded !== null) {\n\n                let willPlayNext = false;\n\n                // check if there is another sound in the queue and if playing\n                // the next one on ended is activated\n                if (nextSound !== null && this._options.playNextOnEnded) {\n                    willPlayNext = true;\n                }\n\n                // if loopQueue is enabled then willPlayNext is always true\n                if (this._options.loopQueue) {\n                    willPlayNext = true;\n                }\n\n                if (!willPlayNext) {\n                    this._playerAudio.freezeAudioContext();\n                }\n\n                currentSound.onEnded(willPlayNext);\n\n            }\n\n            // reset \"first time played\"\n            currentSound.firstTimePlayed = true;\n\n            // reset the \"play time offset\"\n            currentSound.playTimeOffset = 0;\n\n            this._stop(currentSound, PlayerSound.SOUND_STATE_STOPPED);\n\n            if (nextSound !== null) {\n\n                if (this._options.playNextOnEnded) {\n                    this.play({ whichSound: PlayerCore.PLAY_SOUND_NEXT });\n                }\n\n            } else {\n\n                // we reached the end of the queue set the currentIndex back to zero\n                this._currentIndex = 0;\n\n                // if queue loop is active then play\n                if (this._options.loopQueue) {\n                    this.play();\n                }\n\n            }\n\n        }\n\n    }\n\n    /**\n     * whichSound is optional, if set it can be the sound id or if it's\n     * a string it can be next / previous / first / last\n     */\n    protected _getSoundFromQueue({ whichSound, updateIndex = false }: IGetSoundFromQueue = {}): ISound {\n\n        let sound = null;\n        let soundIndex: number = null;\n\n        // check if the queue is empty\n        if (this._queue.length === 0) {\n            return sound;\n        }\n\n        // if which sound to play did not get specified\n        if (whichSound === undefined) {\n            // if whichSound is not defined\n            // AND the currentIndex is null\n            // we set it to first sound in queue\n            soundIndex = 0\n\n            // else we use currentIndex (so the current sound)\n            if (this._currentIndex !== null) {\n                soundIndex = this._currentIndex\n            }\n            sound = this._queue[soundIndex];\n        } else {\n            // if which sound to play is a constant\n            switch (whichSound) {\n                case PlayerCore.CURRENT_SOUND:\n                    if (this._currentIndex !== null) {\n                        sound = this._queue[this._currentIndex];\n                    }\n                    break;\n                case PlayerCore.PLAY_SOUND_NEXT:\n                    if (this._queue[this._currentIndex + 1] !== undefined) {\n                        soundIndex = this._currentIndex + 1;\n                        sound = this._queue[soundIndex];\n                    } else if (this._options.loopQueue) {\n                        // if last sound is playing and loop is enabled\n                        // on next we jump to first sound\n                        soundIndex = 0;\n                        sound = this._queue[soundIndex];\n                    }\n                    break;\n                case PlayerCore.PLAY_SOUND_PREVIOUS:\n                    if (this._queue[this._currentIndex - 1] !== undefined) {\n                        soundIndex = this._currentIndex - 1;\n                        sound = this._queue[soundIndex];\n                    } else if (this._options.loopQueue) {\n                        // if first sound is playing and loop is enabled\n                        // on previous we jump to last sound\n                        soundIndex = this._queue.length - 1;\n                        sound = this._queue[soundIndex];\n                    }\n                    break;\n                case PlayerCore.PLAY_SOUND_FIRST:\n                    if (this._queue.length > 0) {\n                        soundIndex = 0;\n                        sound = this._queue[soundIndex];\n                    }\n                    break;\n                case PlayerCore.PLAY_SOUND_LAST:\n                    if (this._queue.length > 0) {\n                        soundIndex = this._queue.length - 1;\n                        sound = this._queue[soundIndex];\n                    }\n                    break;\n                default:\n                    // if \"which sound to play\" (soundId) is a string or number\n                    [sound, soundIndex] = this._findSoundById({ soundId: whichSound });\n            }\n        }\n\n        if (soundIndex !== null && updateIndex) {\n            this._currentIndex = soundIndex;\n        }\n\n        return sound;\n\n    }\n\n    protected _findSoundById({ soundId }: IFindSoundById): [ISound, number] {\n\n        let sound: ISound = null;\n        let soundIndex = 0;\n\n        this._queue.some((soundFromQueue, index) => {\n\n            if (soundFromQueue.id === soundId) {\n                sound = soundFromQueue;\n                soundIndex = index;\n                return true;\n            }\n\n        });\n\n        return [sound, soundIndex];\n\n    }\n\n    protected _findBestSource(soundSource: (ISoundSource)[] | ISoundSource): IFindBestSourceResponse {\n\n        const bestSource: IBestSource = {\n            url: null,\n            codec: null\n        };\n\n        let sources: (ISoundSource)[];\n\n        // if the source is not an array but a single source object\n        // we first transform it into an array\n        if (!Array.isArray(soundSource)) {\n            sources = [soundSource];\n        } else {\n            sources = soundSource;\n        }\n\n        let i = 0;\n\n        while (i < sources.length) {\n\n            const source = sources[i]\n            let soundUrl = '';\n\n            // if the player had as option a baseUrl for sounds add it now\n            if (this._options.soundsBaseUrl !== '') {\n                soundUrl = this._options.soundsBaseUrl;\n            }\n\n            soundUrl += source.url;\n\n            // check if the codec (if any got specified) is supported\n            // by the device\n            let isCodecSupported = true;\n\n            if (source.codec !== null) {\n                isCodecSupported = this._checkCodecSupport(source.codec);\n            }\n\n            // only if the codec of the source is supported\n            if (isCodecSupported) {\n\n                if (source.isPreferred) {\n                    // if multiple sources but this one if preferred and if previous\n                    // sources also had a supported codec we still overwrite the\n                    // previous match\n                    bestSource.url = soundUrl;\n                    bestSource.codec = source.codec;\n                    // so the source is preferred and supported so we can exit early\n                    break;\n                } else {\n                    // if no best source has been found so far, we don't\n                    // care if it's preferred it's automatically chosen\n                    // as best\n                    bestSource.url = soundUrl;\n                    bestSource.codec = source.codec;\n                    // source is supported, but maybe there is preferred & supported\n                    // so we don't exit the loop just yet\n                }\n\n            }\n\n            i++;\n\n        }\n\n        return bestSource;\n\n    }\n\n    protected _checkCodecSupport(codec: string): boolean {\n\n        let mediaMimeTypes: string[];\n        let error = '';\n\n        switch (codec) {\n            case 'ogg':\n                mediaMimeTypes = ['audio/ogg; codecs=\"vorbis\"'];\n                break;\n            case 'oga':\n                mediaMimeTypes = ['audio/ogg; codecs=\"vorbis\"'];\n                break;\n            case 'mp3':\n                mediaMimeTypes = ['audio/mpeg; codecs=\"mp3\"'];\n                break;\n            case 'opus':\n                mediaMimeTypes = ['audio/ogg; codecs=\"opus\"', 'audio/webm; codecs=\"opus\"'];\n                break;\n            case 'wav':\n                mediaMimeTypes = ['audio/wav; codecs=\"1\"'];\n                break;\n            case 'm4a':\n                mediaMimeTypes = ['audio/m4a;', 'audio/x-m4a;'];\n                break;\n            case 'm4p':\n                mediaMimeTypes = ['audio/m4p;', 'audio/x-m4p;'];\n                break;\n            case 'caf':\n                mediaMimeTypes = ['audio/x-caf;'];\n                break;\n            case 'aac':\n                mediaMimeTypes = ['audio/aac;'];\n                break;\n            case 'weba':\n            case 'webm':\n                mediaMimeTypes = ['audio/webm; codecs=\"vorbis\"'];\n                break;\n            case 'flac':\n                mediaMimeTypes = ['audio/flac;', 'audio/x-flac;'];\n                break;\n            default:\n                error = 'unrecognised codec';\n                break;\n        }\n\n        if (error) {\n            throw new PlayerError(error);\n        }\n\n        return this._checkMimeTypesSupport(mediaMimeTypes);\n\n    }\n\n    protected _checkMimeTypesSupport(mediaMimeTypes: string[]): boolean {\n\n        const deviceAudio = new Audio();\n\n        let isSupported = false;\n\n        mediaMimeTypes.forEach((mediaMimeType) => {\n\n            const isMediaTypeSupported: string = deviceAudio.canPlayType(mediaMimeType).replace(/^no$/, '');\n\n            if (isMediaTypeSupported) {\n                isSupported = true;\n            }\n\n        });\n\n        return isSupported;\n\n    }\n\n    public pause(): void {\n\n        // get the current sound\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        if (currentSound === null) {\n            return;\n        }\n\n        if (currentSound.state === PlayerSound.SOUND_STATE_PAUSED) {\n            // TODO: just return or throw an error\n            return;\n        }\n\n        const timeAtPause = currentSound.getCurrentTime();\n\n        currentSound.playTimeOffset += timeAtPause - currentSound.startTime;\n\n        // trigger paused event\n        if (currentSound.onPaused !== null) {\n            currentSound.onPaused(currentSound.playTimeOffset);\n        }\n\n        this._stop(currentSound, PlayerSound.SOUND_STATE_PAUSED);\n\n    }\n\n    public stop(): void {\n\n        // get the current sound\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        if (currentSound === null) {\n            return;\n        }\n\n        // check if sound is already stopped\n        if (currentSound.state === PlayerSound.SOUND_STATE_STOPPED) {\n            // TODO: just return or throw an error\n            return;\n        }\n\n        // freeze the audio context\n        this._playerAudio.freezeAudioContext();\n\n        const timeAtStop = currentSound.getCurrentTime();\n\n        currentSound.playTimeOffset += timeAtStop - currentSound.startTime;\n\n        // trigger stopped event\n        if (currentSound.onStopped !== null) {\n            currentSound.onStopped(currentSound.playTimeOffset);\n        }\n\n        this._stop(currentSound, PlayerSound.SOUND_STATE_STOPPED);\n\n    }\n\n    protected _stop(sound: ISound, soundState: typeSoundStates): void {\n\n        // if it is fully stopped, not just paused\n        if (soundState === PlayerSound.SOUND_STATE_STOPPED) {\n            // reset the playTimeOffset\n            sound.playTimeOffset = 0;\n            // reset the \"is ready to pLay\"\n            //sound.isReadyToPLay = false;\n            // reset \"first time played\"\n            sound.firstTimePlayed = true;\n        }\n\n        if (sound.sourceNode !== null) {\n\n            if (sound.sourceNode instanceof AudioBufferSourceNode) {\n                // to stop playing if using the AudioBufferSourceNode use the stop method\n                sound.sourceNode.stop(0);\n            } else if (sound.sourceNode instanceof MediaElementAudioSourceNode) {\n                // to stop playing if using the MediaElementAudioSourceNode use the pause method\n                sound.sourceNode.mediaElement.pause();\n            }\n\n            this._playerAudio.disconnectSound(sound);\n\n            // state is now stopped\n            sound.state = soundState;\n\n            if (this._playingProgressRequestId !== null) {\n                cancelAnimationFrame(this._playingProgressRequestId);\n                this._playingProgressPreviousTimestamp = 0;\n            }\n\n        }\n\n    }\n\n    public next(): void {\n\n        // alias for play next\n        this.play({ whichSound: PlayerCore.PLAY_SOUND_NEXT });\n\n    }\n\n    public previous(): void {\n\n        // alias for play previous\n        this.play({ whichSound: PlayerCore.PLAY_SOUND_PREVIOUS });\n\n    }\n\n    public first(): void {\n\n        // alias for play first\n        this.play({ whichSound: PlayerCore.PLAY_SOUND_FIRST });\n\n    }\n\n    public last(): void {\n\n        // alias for play last\n        this.play({ whichSound: PlayerCore.PLAY_SOUND_LAST });\n\n    }\n\n    protected _playingProgress(sound: ISound): void {\n\n        const timeNow = sound.getCurrentTime();\n\n        sound.playTime = (timeNow - sound.startTime) + sound.playTimeOffset;\n\n        const duration = sound.getDuration();\n        const playingPercentage = (sound.playTime / duration) * 100;\n\n        sound.playedTimePercentage = playingPercentage;\n\n        sound.onPlaying(playingPercentage, duration, sound.playTime);\n\n    }\n\n    public setVisibilityAutoMute(visibilityAutoMute: boolean): void {\n\n        this._options.visibilityAutoMute = visibilityAutoMute;\n\n        if (visibilityAutoMute) {\n            document.addEventListener('visibilitychange', this._handleVisibilityChange.bind(this), false);\n        } else {\n            document.removeEventListener('visibilitychange', this._handleVisibilityChange.bind(this), false);\n        }\n\n    }\n\n    public getVisibilityAutoMute(): boolean {\n        return this._options.visibilityAutoMute;\n    }\n\n    protected _handleVisibilityChange(): void {\n\n        let hiddenKeyword: string;\n\n        if (typeof document.hidden !== 'undefined') { // Opera 12.10 and Firefox 18 and later support\n            hiddenKeyword = 'hidden';\n\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof (document as any).msHidden !== 'undefined') {\n            hiddenKeyword = 'msHidden';\n\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof (document as any).webkitHidden !== 'undefined') {\n            hiddenKeyword = 'webkitHidden';\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if ((document as any)[hiddenKeyword]) {\n            this.mute();\n        } else {\n            this.unMute();\n        }\n    }\n\n    public async disconnect(): Promise<void> {\n\n        // adding another check here to cancel animation frame because:\n        // a player can be disconnect while song is paused or playing\n        // which means the cancelAnimationFrame in _stop would never get triggered\n        if (this._playingProgressRequestId !== null) {\n            cancelAnimationFrame(this._playingProgressRequestId);\n        }\n\n        await this._playerAudio.shutDown(this._queue);\n\n    }\n\n    public async getAudioContext(): Promise<AudioContext> {\n\n        const audioContext = await this._playerAudio.getAudioContext();\n\n        return audioContext;\n\n    }\n\n}\n"],"names":["PlayerSound","soundAttributes","this","url","codec","sourceNode","gainNode","isReadyToPLay","isBuffered","isBuffering","audioElement","audioBuffer","arrayBuffer","audioBufferDate","playTimeOffset","startTime","playTime","playedTimePercentage","state","loadingProgress","duration","firstTimePlayed","Array","isArray","source","id","_generateSoundId","loop","onLoading","onPlaying","onStarted","onEnded","onStopped","onPaused","onResumed","ArrayBuffer","AudioBuffer","Date","getDuration","prototype","getCurrentTime","currentTime","AudioBufferSourceNode","context","MediaElementAudioSourceNode","buffer","now","toString","Math","random","substring","SOUND_STATE_STOPPED","SOUND_STATE_PAUSED","SOUND_STATE_PLAYING","PlayerError","_super","message","code","_this","call","Object","setPrototypeOf","__extends","Error","PlayerAudio","options","_audioContext","_volume","_audioNodes","_options","_initialize","createAudioContextOnFirstUserInteraction","_addAutoCreateAudioContextOnFirstUserInteractionEventListeners","decodeAudio","getAudioContext","_a","sent","decodeAudioData","audioBufferPromise","Promise","resolve","_createAudioContext","reject","AudioContext","WebAudioContext","window","webkitAudioContext","audioContext","error","document","addEventListener","bind","_removeAutoCreateAudioContextOnFirstUserInteractionEventListeners","removeEventListener","_unfreezeAudioContext","suspend","resume","freezeAudioContext","detectAudioContextSupport","audioContextSupported","detectAudioElementSupport","createElement","canPlayType","shutDown","songsQueue","forEach","sound","mediaElement","remove","disconnect","_disconnectPlayerGainNode","_destroyAudioContext","close","createAudioBufferSourceNode","audioBufferSourceOptions","audioBufferSourceNode","createBufferSource","createGain","gain","value","connect","onended","event","onSourceNodeEnded","createMediaElementSourceNode","sourceNodeOptions","mediaElementAudioSourceNode","createMediaElementSource","__awaiter","_getPlayerGainNode","GainNode","destination","_initializeVolume","connectSound","playerGainNode","soundGainNode","disconnectSound","_changePlayerGainValue","gainValue","_roundGainTwoDecimals","rawGainValue","round","Number","EPSILON","setVolume","volume","forceUpdateUserVolume","persistVolume","localStorage","setItem","getVolume","userVolumeInPercent","parseInt","getItem","isNaN","PlayerRequest","getArrayBuffer","requested","xhr","XMLHttpRequest","open","responseType","onload","status","response","statusText","onprogress","percentage","total","loaded","onerror","send","PlayerCore","playerOptions","_playingProgressRequestId","_playingProgressPreviousTimestamp","_progressTrigger","timestamp","playingProgressIntervalTime","_playingProgress","requestAnimationFrame","defaultOptions","loopQueue","loopSong","soundsBaseUrl","playNextOnEnded","stopOnReset","visibilityAutoMute","loadPlayerMode","assign","_queue","_currentIndex","audioOptions","_audioOptions","_playerAudio","PLAYER_MODE_AUDIO","PLAYER_MODE_AJAX","addSoundToQueue","_b","whereInQueue","WHERE_IN_QUEUE_AT_END","_appendSoundToQueue","WHERE_IN_QUEUE_AT_START","_prependSoundToQueue","push","unshift","resetQueue","stop","reset","getQueue","setLoopQueue","loppQueue","getLoopQueue","mute","currentVolume","_postMuteVolume","unMute","isMuted","setPosition","soundPositionInPercent","currentSound","_getSoundFromQueue","whichSound","CURRENT_SOUND","_loadSound","then","soundPositionInSeconds","setPositionInSeconds","catch","play","loadSoundPromise","notImplementedError","_loadSoundUsingAudioElement","_loadSoundUsingRequest","PLAYER_MODE_FETCH","_findBestSource","audioElement_1","Audio","crossOrigin","src","controls","autoplay","body","appendChild","_initializeAudioElementListeners","canplaythroughListener_1","errorListener_1","soundLoadingError","noUrlError","request","_decodeSound","requestError","decodeAudioError","_cloneAudioBuffer","fromAudioBuffer","length","numberOfChannels","sampleRate","channelI","samples","getChannelData","copyToChannel","updateIndex","_stop","undefined","_play","_playAudioBuffer","_playMediaElementAudio","_triggerSoundCallbacks","sourceOptions","_onEnded","error_1","start","error_2","nextSound","PLAY_SOUND_NEXT","willPlayNext","_c","_d","soundIndex","PLAY_SOUND_PREVIOUS","PLAY_SOUND_FIRST","PLAY_SOUND_LAST","_findSoundById","soundId","some","soundFromQueue","index","soundSource","sources","bestSource","i","soundUrl","isCodecSupported","_checkCodecSupport","isPreferred","mediaMimeTypes","_checkMimeTypesSupport","deviceAudio","isSupported","mediaMimeType","replace","pause","timeAtPause","timeAtStop","soundState","cancelAnimationFrame","next","previous","first","last","timeNow","playingPercentage","setVisibilityAutoMute","_handleVisibilityChange","getVisibilityAutoMute","hiddenKeyword","hidden","msHidden","webkitHidden"],"mappings":"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"}