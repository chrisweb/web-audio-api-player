{"version":3,"file":"index.min.js","sources":["../src/library/sound.ts","../src/library/audio.ts","../src/library/request.ts","../src/library/core.ts"],"sourcesContent":["const SOUND_STATE_STOPPED = 'sound_state_stopped';\nconst SOUND_STATE_PAUSED = 'sound_state_paused';\nconst SOUND_STATE_PLAYING = 'sound_state_playing';\nconst SOUND_STATE_SEEKING = 'sound_state_seeking';\n\nexport type typeSoundStates = typeof SOUND_STATE_STOPPED | typeof SOUND_STATE_PAUSED | typeof SOUND_STATE_PLAYING | typeof SOUND_STATE_SEEKING;\n\nexport interface IOnProgress {\n    (playingPercentage: number, duration: number, playTime: number): void;\n}\n\nexport interface IOnEnded {\n    (willPlayNext: boolean): void;\n}\n\nexport interface IOnStarted {\n    (playTimeOffset: number): void;\n}\n\nexport interface IOnPaused {\n    (playTime: number): void;\n}\n\nexport interface IOnResumed {\n    (playTime: number): void;\n}\n\nexport interface IOnStopped {\n    (playTime: number): void;\n}\n\nexport interface IOnSeeking {\n    (seekingPercentage: number, duration: number, playTime: number): void;\n}\n\nexport interface ISoundSource {\n    url: string;\n    codec?: string;\n    isPreferred?: boolean;\n}\n\nexport interface ISoundAttributes {\n    // source(s) are NOT mandatory as user can provide an arrayBuffer\n    // and / or audioBuffer in which case the source url is not needed\n    source?: (ISoundSource)[] | ISoundSource;\n    id?: number | string;\n    loop?: boolean;\n    audioBuffer?: AudioBuffer;\n    arrayBuffer?: ArrayBuffer;\n    duration?: number;\n\n    // events\n    onLoading?: IOnProgress;\n    onPlaying?: IOnProgress;\n    onEnded?: IOnEnded;\n    onStarted?: IOnStarted;\n    onStopped?: IOnStopped;\n    onPaused?: IOnPaused;\n    onResumed?: IOnResumed;\n    onSeeking?: IOnSeeking;\n}\n\nexport interface ISound extends ISoundAttributes, ISoundSource {\n    sourceNode: AudioBufferSourceNode | MediaElementAudioSourceNode;\n    gainNode: GainNode;\n    isReadyToPLay: boolean;\n    isBuffered: boolean;\n    isBuffering: boolean;\n    audioElement: HTMLAudioElement;\n    audioBufferDate: Date;\n    playTimeOffset: number;\n    startTime: number;\n    playTime: number;\n    elapsedPlayTime: number;\n    playedTimePercentage: number;\n    state: typeSoundStates;\n    loadingProgress: number;\n    firstTimePlayed: boolean;\n    isConnectToPlayerGain: boolean;\n    getCurrentTime(): number;\n    getDuration(): number;\n}\n\nexport class PlayerSound implements ISound {\n\n    // static constants\n    static readonly SOUND_STATE_STOPPED = 'sound_state_stopped';\n    static readonly SOUND_STATE_PAUSED = 'sound_state_paused';\n    static readonly SOUND_STATE_PLAYING = 'sound_state_playing';\n    static readonly SOUND_STATE_SEEKING = 'sound_state_seeking';\n\n    // properties\n    public source: (ISoundSource)[] | ISoundSource;\n    public url: string = null;\n    public codec: string = null;\n    public id: number | string;\n    public loop: boolean = false;\n    public sourceNode: AudioBufferSourceNode | MediaElementAudioSourceNode = null;\n    public gainNode: GainNode = null;\n    public isReadyToPLay = false;\n    public isBuffered = false;\n    public isBuffering = false;\n    public audioElement: HTMLAudioElement = null;\n    public audioBuffer: AudioBuffer = null;\n    public arrayBuffer: ArrayBuffer = null;\n    public audioBufferDate: Date = null;\n    public playTimeOffset = 0;\n    public startTime = 0;\n    // elapsedPlayTime is used to adjust the playtime\n    // when playing audio buffers\n    // on seek, pause or when there is a playTimeOffset\n    // see getCurrentTime function\n    public elapsedPlayTime = 0;\n    public playTime = 0;\n    public playedTimePercentage = 0;\n    public state: typeSoundStates = SOUND_STATE_STOPPED;\n    public loadingProgress = 0;\n    public duration: number = null;\n    public firstTimePlayed = true;\n    public isConnectToPlayerGain = false;\n\n    // callbacks\n    public onLoading: IOnProgress;\n    public onPlaying: IOnProgress;\n    public onEnded: IOnEnded;\n    public onStarted: IOnStarted;\n    public onStopped: IOnStopped;\n    public onPaused: IOnPaused;\n    public onResumed: IOnResumed;\n    public onSeeking?: IOnSeeking;\n\n    constructor(soundAttributes: ISoundAttributes) {\n\n        // user provided values\n        if (!Array.isArray(soundAttributes.source)) {\n            this.source = [soundAttributes.source];\n        } else {\n            this.source = soundAttributes.source;\n        }\n\n        if (typeof soundAttributes.id !== 'undefined') {\n            this.id = soundAttributes.id;\n        } else {\n            this.id = this._generateSoundId()\n        }\n\n        this.loop = soundAttributes.loop || false;\n\n        // the user can set the duration manually\n        // this is usefull if we need to convert the position percentage into seconds but don't want to preload the song\n        // to get the duration the song has to get preloaded as the duration is a property of the audioBuffer\n        this.duration = soundAttributes.duration || null;\n\n        if (typeof soundAttributes.onLoading === 'function') {\n            this.onLoading = soundAttributes.onLoading;\n        } else {\n            this.onLoading = null;\n        }\n\n        if (typeof soundAttributes.onPlaying === 'function') {\n            this.onPlaying = soundAttributes.onPlaying;\n        } else {\n            this.onPlaying = null;\n        }\n\n        if (typeof soundAttributes.onStarted === 'function') {\n            this.onStarted = soundAttributes.onStarted;\n        } else {\n            this.onStarted = null;\n        }\n\n        if (typeof soundAttributes.onEnded === 'function') {\n            this.onEnded = soundAttributes.onEnded;\n        } else {\n            this.onEnded = null;\n        }\n\n        if (typeof soundAttributes.onStopped === 'function') {\n            this.onStopped = soundAttributes.onStopped;\n        } else {\n            this.onStopped = null;\n        }\n\n        if (typeof soundAttributes.onPaused === 'function') {\n            this.onPaused = soundAttributes.onPaused;\n        } else {\n            this.onPaused = null;\n        }\n\n        if (typeof soundAttributes.onResumed === 'function') {\n            this.onResumed = soundAttributes.onResumed;\n        } else {\n            this.onResumed = null;\n        }\n\n        if (typeof soundAttributes.onSeeking === 'function') {\n            this.onSeeking = soundAttributes.onSeeking;\n        } else {\n            this.onSeeking = null;\n        }\n\n        if (soundAttributes.arrayBuffer instanceof ArrayBuffer) {\n            this.arrayBuffer = soundAttributes.arrayBuffer;\n        }\n\n        if (soundAttributes.audioBuffer instanceof AudioBuffer) {\n            this.audioBuffer = soundAttributes.audioBuffer;\n            this.isBuffering = false;\n            this.isBuffered = true;\n            this.audioBufferDate = new Date();\n            this.duration = this.getDuration();\n        }\n\n    }\n\n    public getCurrentTime(): number {\n\n        let currentTime: number;\n\n        if (this.sourceNode !== null) {\n            if (this.sourceNode instanceof AudioBufferSourceNode) {\n                currentTime = (this.sourceNode.context.currentTime - this.startTime) + this.elapsedPlayTime;\n            } else if (this.sourceNode instanceof MediaElementAudioSourceNode) {\n                currentTime = this.audioElement.currentTime;\n            }\n        }\n\n        \n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n        const currentTimeRounded = Math.round((currentTime + Number.EPSILON) * 100) / 100;\n\n        return currentTimeRounded;\n\n    }\n\n    public getDuration(): number {\n\n        let duration: number;\n\n        if (this.sourceNode !== null) {\n            if (this.sourceNode instanceof AudioBufferSourceNode) {\n                duration = this.audioBuffer.duration;\n            } else if (this.sourceNode instanceof MediaElementAudioSourceNode) {\n                duration = this.audioElement.duration;\n            }\n        }\n\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n        const durationRounded = Math.round((duration + Number.EPSILON) * 100) / 100;\n\n        return durationRounded;\n\n    }\n\n    protected _generateSoundId() {\n        return Date.now().toString(36) + Math.random().toString(36).substring(2)\n    }\n\n}\n","import { ISound } from './sound';\n\ntype OnEndedCallbackType = (event: Event) => void\n\nexport interface IAudioOptions {\n    audioContext: AudioContext;\n    createAudioContextOnFirstUserInteraction: boolean;\n    volume: number;\n    persistVolume: boolean;\n    loadPlayerMode: string;\n    addAudioElementsToDom: boolean;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/AudioNode\nexport interface IAudioNodes {\n    // https://developer.mozilla.org/en-US/docs/Web/API/GainNode\n    gainNode: GainNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/PannerNode\n    pannerNode?: PannerNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/StereoPannerNode\n    stereoPannerNode?: StereoPannerNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/DelayNode\n    delayNode?: DelayNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ScriptProcessorNode\n    scriptProcessorNode?: ScriptProcessorNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode\n    analyserNode?: AnalyserNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n    biquadFilterNode?: BiquadFilterNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ChannelMergerNode\n    channelMergeNode?: ChannelMergerNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ChannelSplitterNode\n    channelSplitterNode?: ChannelSplitterNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ConvolverNode\n    convolverNode?: ConvolverNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode\n    dynamicCompressorNode?: DynamicsCompressorNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode\n    oscillatorNode?: OscillatorNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/WaveShaperNode\n    waveShaperNode?: WaveShaperNode;\n}\n\nexport class PlayerAudio {\n\n    protected _options;\n    protected _audioContext: AudioContext = null;\n    protected _volume: number = null;\n    protected _audioNodes: IAudioNodes = {\n        gainNode: null,\n    };\n    protected _audioElement: HTMLAudioElement = null;\n    protected _mediaElementAudioSourceNode: MediaElementAudioSourceNode = null;\n    protected _isAudioUnlocked: boolean = false;\n\n    constructor(options: IAudioOptions) {\n\n        this._options = options;\n\n        this._initialize();\n\n    }\n\n    protected _initialize(): void {\n\n        // I was planning on using the \"first user interaction hack\" only (on mobile)\n        // for this I would have checked the if the autoplay policy prevents me\n        // from playing a sound programmatically (without user click)\n        // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getAutoplayPolicy\n        // but this feature is only implemented on firefox (as of 19.09.2023)\n\n        if (this._options.createAudioContextOnFirstUserInteraction) {\n            this._addFirstUserInteractionEventListeners();\n        }\n\n    }\n\n    public getAudioNodes() {\n        return this._audioNodes;\n    }\n\n    public async decodeAudio(arrayBuffer: ArrayBuffer): Promise<AudioBuffer> {\n\n        const audioContext = await this.getAudioContext();\n\n        // Note to self:\n        // the new decodeAudioData returns a promise, older versions accept as second\n        // and third parameter, which are a success and an error callback funtion\n        // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/decodeAudioData\n\n        return await audioContext.decodeAudioData(arrayBuffer);\n\n    }\n\n    protected _createAudioContext(): Promise<void> {\n\n        if (this._audioContext instanceof AudioContext) {\n            // if already created, no need to create a new one\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const WebAudioContext: typeof AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n\n        // initialize the audio context\n        if (this._options.audioContext !== null) {\n            this._audioContext = this._options.audioContext;\n        } else {\n            this._audioContext = new WebAudioContext();\n        }\n\n    }\n\n    protected _addFirstUserInteractionEventListeners(): void {\n\n        if (this._options.createAudioContextOnFirstUserInteraction) {\n            document.addEventListener('touchstart', this.unlockAudio.bind(this));\n            document.addEventListener('touchend', this.unlockAudio.bind(this));\n            document.addEventListener('mousedown', this.unlockAudio.bind(this));\n        }\n\n    }\n\n    protected _removeFirstUserInteractionEventListeners(): void {\n\n        if (this._options.createAudioContextOnFirstUserInteraction) {\n            document.removeEventListener('touchstart', this.unlockAudio.bind(this));\n            document.removeEventListener('touchend', this.unlockAudio.bind(this));\n            document.removeEventListener('mousedown', this.unlockAudio.bind(this));\n        }\n\n    }\n\n    public unlockAudio(): Promise<void> {\n\n        return new Promise((resolve, reject) => {\n\n            if (this._isAudioUnlocked) {\n                resolve();\n            }\n\n            // make sure the audio context is not suspended\n            // on android this is what unlocks audio\n            this.getAudioContext().then(() => {\n\n                // create an (empty) buffer\n                const placeholderBuffer = this._audioContext.createBuffer(1, 1, 22050);\n\n                // https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/createBufferSource\n                let bufferSource = this._audioContext.createBufferSource();\n\n                bufferSource.onended = () => {\n\n                    bufferSource.disconnect(0);\n\n                    this._removeFirstUserInteractionEventListeners();\n\n                    bufferSource.disconnect(0);\n\n                    bufferSource.buffer = null;\n                    bufferSource = null;\n\n                    if (this._options.loadPlayerMode === 'player_mode_audio') {\n\n                        // on iOS (mobile) the audio element you want to use needs to have been created\n                        // as a direct result of an user interaction\n                        // after it got unlocked we re-use that element for all sounds\n                        this._createAudioElementAndSource().then(() => {\n                            this._isAudioUnlocked = true;\n                            resolve();\n                        }).catch(reject);\n\n                    } else if (this._options.loadPlayerMode === 'player_mode_ajax') {\n                        this._isAudioUnlocked = true;\n                        resolve();\n                    }\n\n                };\n\n                bufferSource.buffer = placeholderBuffer;\n                bufferSource.connect(this._audioContext.destination);\n                bufferSource.start(0);\n\n            }).catch(reject);\n\n        });\n\n    }\n\n    protected async _createAudioElementAndSource(): Promise<void> {\n\n        await this._createAudioElement();\n\n        await this._createMediaElementAudioSourceNode();\n\n    }\n\n    protected async _createAudioElement(): Promise<void> {\n\n        if (this._audioElement === null) {\n\n            const audioElement = new Audio();\n\n            audioElement.controls = false;\n            audioElement.autoplay = false;\n            audioElement.preload = 'metadata';\n            audioElement.volume = 1;\n            audioElement.id = 'web-audio-api-player';\n\n            this._audioElement = audioElement;\n\n            if (this._options.addAudioElementsToDom) {\n                document.body.appendChild(audioElement);\n            }\n\n        }\n\n    }\n\n    public getAudioElement(): HTMLAudioElement {\n\n        return this._audioElement;\n\n    }\n\n    public async getAudioContext(): Promise<AudioContext> {\n\n        if (this._audioContext === null || this._audioContext.state === 'closed') {\n            await this._createAudioContext();\n        } else if (this._audioContext.state === 'suspended') {\n            await this.unfreezeAudioContext();\n        }\n\n        return this._audioContext;\n\n    }\n\n    public unfreezeAudioContext(): Promise<void> {\n\n        // did resume get implemented\n        if (typeof this._audioContext.resume === 'undefined') {\n\n            // this browser does not support resume\n            // just send back a promise as resume would do\n            return Promise.resolve();\n\n        } else {\n\n            // resume the audio hardware access\n            // audio context resume returns a promise\n            // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/resume\n            return this._audioContext.resume();\n\n        }\n\n    }\n\n    public freezeAudioContext(): Promise<void> {\n\n        // did suspend get implemented\n        if (typeof this._audioContext.suspend === 'undefined') {\n\n            return Promise.resolve();\n\n        } else {\n\n            // halt the audio hardware access temporarily to reduce CPU and battery usage\n            return this._audioContext.suspend();\n\n        }\n\n    }\n\n    public isAudioContextFrozen(): boolean {\n\n        return this._audioContext.state === 'suspended' ? true : false;\n\n    }\n\n    public detectAudioContextSupport(): boolean {\n\n        // basic audio context detection\n        let audioContextSupported = false;\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (typeof (window as any).webkitAudioContext !== 'undefined') {\n            audioContextSupported = true;\n        } else if (typeof AudioContext !== 'undefined') {\n            audioContextSupported = true;\n        }\n\n        return audioContextSupported;\n\n    }\n\n    public detectAudioElementSupport(): boolean {\n\n        // basic audio element detection\n        return !!document.createElement('audio').canPlayType;\n\n    }\n\n    protected async _createAudioBufferSourceNode(): Promise<AudioBufferSourceNode> {\n\n        const audioContext = await this.getAudioContext();\n\n        return audioContext.createBufferSource();\n\n    }\n\n    protected async _createMediaElementAudioSourceNode(): Promise<void> {\n\n        if (this._mediaElementAudioSourceNode === null) {\n\n            const audioContext = await this.getAudioContext();\n\n            // createMediaElementSource: https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createMediaElementSource\n            this._mediaElementAudioSourceNode = audioContext.createMediaElementSource(this._audioElement);\n\n        }\n\n    }\n\n    protected _destroyMediaElementAudioSourceNode(): void {\n\n        if (this._mediaElementAudioSourceNode !== null) {\n\n            if (typeof this._mediaElementAudioSourceNode.mediaElement !== 'undefined') {\n                this._mediaElementAudioSourceNode.mediaElement.remove();\n            }\n\n            this._mediaElementAudioSourceNode.disconnect();\n            this._mediaElementAudioSourceNode = null;\n        }\n\n    }\n\n    protected _destroyAudioBufferSourceNode(): void {\n\n        if (this._mediaElementAudioSourceNode !== null) {\n\n            this._mediaElementAudioSourceNode.disconnect();\n\n        }\n\n    }\n\n    protected async _destroyAudioContext(): Promise<void> {\n\n        if (this._audioContext !== null && this._audioContext.state !== 'closed') {\n            await this._audioContext.close();\n            this._audioContext = null;\n        }\n\n    }\n\n    public async shutDown(songsQueue: ISound[]): Promise<void> {\n\n        this._removeFirstUserInteractionEventListeners();\n\n        songsQueue.forEach((sound) => {\n            this.disconnectSound(sound);\n        });\n\n        this._destroyMediaElementAudioSourceNode();\n        this._destroyAudioBufferSourceNode();\n\n        this._disconnectPlayerGainNode();\n\n        await this._destroyAudioContext();\n\n    }\n\n\n    protected async _getPlayerGainNode(): Promise<GainNode> {\n\n        // the player (master) gain node\n        let gainNode: GainNode;\n\n        if (this._audioNodes.gainNode instanceof GainNode) {\n\n            gainNode = this._audioNodes.gainNode;\n\n        } else {\n\n            const audioContext = await this.getAudioContext();\n\n            // Note: a volume control (GainNode) should always\n            // be the last node that gets connected\n            // so that volume changes take immediate effect\n            gainNode = audioContext.createGain();\n\n            this._initializeVolume(gainNode);\n\n            // final step: connect the gain node to the audio destination node\n            gainNode.connect(audioContext.destination);\n\n            this._audioNodes.gainNode = gainNode;\n\n        }\n\n        return gainNode;\n\n    }\n\n    protected _disconnectPlayerGainNode(): void {\n\n        if (this._audioNodes.gainNode !== null) {\n            this._audioNodes.gainNode.disconnect();\n            this._audioNodes.gainNode = null;\n        }\n\n    }\n\n    public async connectSound(sound: ISound, onEndedCallback: OnEndedCallbackType): Promise<void> {\n\n        if (sound.isConnectToPlayerGain) {\n            return;\n        }\n\n        if (this._options.loadPlayerMode === 'player_mode_ajax') {\n\n            // get a new audio buffer source node\n            // Note: remember these are one use only\n            // https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode\n            const audioBufferSourceNode = await this._createAudioBufferSourceNode();\n\n            // create the sound gain node\n            sound.gainNode = audioBufferSourceNode.context.createGain();\n\n            // connect the source to the sound gain node\n            audioBufferSourceNode.connect(sound.gainNode);\n\n            // do we loop this song\n            audioBufferSourceNode.loop = sound.loop;\n\n            // NOTE: the source nodes onended handler won't have any effect if the loop property\n            // is set to true, as the audio won't stop playing\n            audioBufferSourceNode.onended = onEndedCallback;\n\n            sound.sourceNode = audioBufferSourceNode;\n\n        } else if (this._options.loadPlayerMode === 'player_mode_audio') {\n\n            // create the sound gain node\n            sound.gainNode = this._mediaElementAudioSourceNode.context.createGain();\n\n            // connect the source to the sound gain node\n            this._mediaElementAudioSourceNode.connect(sound.gainNode);\n\n            // do we loop this song\n            this._mediaElementAudioSourceNode.mediaElement.loop = sound.loop;\n\n            // NOTE: the source nodes onended handler won't have any effect if the loop property\n            // is set to true, as the audio won't stop playing\n            this._mediaElementAudioSourceNode.mediaElement.onended = onEndedCallback;\n\n            sound.sourceNode = this._mediaElementAudioSourceNode;\n\n        }\n\n        // set the gain by default always to 1\n        // TODO: allow user to define a gain value for each sound via sound options\n        // this allows to normalize the gain of all sounds in a playlist\n        // TODO: in future allow a sound gain to be faded in or out\n        // without having to change the main player gain\n        sound.gainNode.gain.value = 1;\n\n        const playerGainNode = await this._getPlayerGainNode();\n\n        sound.gainNode.connect(playerGainNode);\n        sound.isConnectToPlayerGain = true;\n\n    }\n\n    public async disconnectSound(sound: ISound): Promise<void> {\n\n        if (!sound.isConnectToPlayerGain) {\n            return;\n        }\n\n        if (sound.sourceNode !== null) {\n            sound.sourceNode.disconnect();\n            // we set the source node to null, so that it can get garbage collected\n            // as specified in the specs: you can't reuse an audio buffer source node,\n            // after it got stopped\n            sound.sourceNode = null;\n        }\n\n        if (sound.gainNode !== null) {\n            sound.gainNode.disconnect();\n            sound.gainNode = null;\n            sound.isConnectToPlayerGain = false;\n        }\n\n        if (sound.audioElement !== null) {\n            sound.audioElement = null;\n        }\n\n    }\n\n    protected async _changePlayerGainValue(gainValue: number): Promise<void> {\n\n        if (this._audioNodes.gainNode instanceof GainNode) {\n            const audioContext = await this.getAudioContext();\n            this._audioNodes.gainNode.gain.setTargetAtTime(gainValue, audioContext.currentTime, 0.1);\n        }\n\n    }\n\n    public async setVolume(volume: number, forceUpdateUserVolume = true): Promise<number> {\n\n        // we sometimes change the volume, for a fade in/out or when muting, but\n        // in this cases we don't want to update the user's persisted volume, in\n        // which case forceUpdateUserVolume is false else it would be true\n        if (this._options.persistVolume && forceUpdateUserVolume) {\n            localStorage.setItem('WebAudioAPIPlayerVolume', volume.toString());\n        }\n\n        // the gain values we use range from 0 to 1\n        // so we need to divide the volume (in percent) by 100 to get the gain value\n        const newGainValue = volume / 100;\n\n        if (this._audioNodes.gainNode instanceof GainNode) {\n\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n            const currentGainRounded = Math.round((this._audioNodes.gainNode.gain.value + Number.EPSILON) * 100) / 100;\n\n            // check if the volume changed\n            if (newGainValue !== currentGainRounded) {\n\n                // the gain value changes the amplitude of the sound wave\n                // a gain value of one does nothing\n                // values between 0 and 1 reduce the loudness, above one they amplify the loudness\n                // negative values work too, but they invert the waveform, so -1 is as loud as 1\n                await this._changePlayerGainValue(newGainValue);\n\n            }\n\n        }\n\n        this._volume = volume;\n\n        return volume;\n\n    }\n\n    public getVolume(): number {\n\n        let volume: number;\n\n        // check if volume has already been set\n        if (this._volume !== null) {\n            volume = this._volume;\n        } else {\n            if (this._options.persistVolume) {\n                // if persist volume is enabled, check if there is a user volume in localstorage\n                const userVolumeInPercent = parseInt(localStorage.getItem('WebAudioAPIPlayerVolume'));\n\n                if (!isNaN(userVolumeInPercent)) {\n                    volume = userVolumeInPercent;\n                }\n            }\n\n            // if volume is not persisted or persited value not yet set\n            if (typeof volume === 'undefined') {\n                volume = this._options.volume;\n            }\n            this._volume = volume;\n        }\n\n        return volume;\n\n    }\n\n    protected _initializeVolume(gainNode: GainNode): void {\n\n        if (this._options.persistVolume) {\n            // if persist volume is enabled, check if there is a user volume in localstorage\n            const userVolumeInPercent = parseInt(localStorage.getItem('WebAudioAPIPlayerVolume'));\n            const gainValue = userVolumeInPercent / 100;\n\n            if (!isNaN(userVolumeInPercent)) {\n                gainNode.gain.value = gainValue;\n            }\n\n            this._volume = userVolumeInPercent;\n        }\n\n\n        // if no user volume take the default options volume\n        if (this._volume === null) {\n            const gainValue = this._options.volume / 100;\n            gainNode.gain.value = gainValue;\n            this._volume = this._options.volume;\n        }\n\n    }\n\n}\n","import { IOnProgress } from './sound';\n\nexport interface IRequested {\n    url: string;\n    loadingProgress: number;\n    onLoading?: IOnProgress;\n}\n\nexport class PlayerRequest {\n\n    public getArrayBuffer(requested: IRequested): Promise<ArrayBuffer> {\n\n        return new Promise(function (resolve, reject) {\n\n            const xhr = new XMLHttpRequest();\n\n            // TODO: abort the request?\n            // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/abort\n\n            // thirs parameter is for \"async\", default true but who knows if prefer to explicitly set it just in case\n            xhr.open('GET', requested.url, true);\n\n            // set the expected response type from the server to arraybuffer\n            xhr.responseType = 'arraybuffer';\n\n            xhr.onload = function (): void {\n\n                // gets called even on for example 404, so check the status\n                if (xhr.status === 200) {\n\n                    // successful request so now we can resolve the promise\n                    resolve(xhr.response);\n\n                } else {\n\n                    // something went wrong so we reject with an error\n                    reject(new Error(xhr.statusText + '(status:' + xhr.status + ')'));\n\n                }\n\n            };\n\n            xhr.onprogress = function (event): void {\n\n                const loadingPercentageRaw = 100 / (event.total / event.loaded);\n\n                // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n                const loadingPercentage = Math.round(loadingPercentageRaw);\n\n                // update value on sound object\n                requested.loadingProgress = loadingPercentage;\n\n                if (requested.onLoading !== null) {\n                    requested.onLoading(loadingPercentage, event.total, event.loaded);\n                }\n\n            };\n\n            // also reject for any kind of network errors\n            xhr.onerror = function (error): void {\n\n                reject(error);\n\n            };\n\n            // now make the request\n            xhr.send();\n\n        });\n\n    }\n\n}\n","import { PlayerSound, ISound, ISoundAttributes, ISoundSource, typeSoundStates } from './sound';\nimport {\n    PlayerAudio,\n    IAudioOptions,\n} from './audio';\nimport { PlayerRequest } from './request';\n\nconst PLAYER_MODE_AUDIO = 'player_mode_audio';\nconst PLAYER_MODE_AJAX = 'player_mode_ajax';\nconst PLAYER_MODE_FETCH = 'player_mode_fetch';\n\nconst WHERE_IN_QUEUE_AT_START = 'prepend';\nconst WHERE_IN_QUEUE_AT_END = 'append';\n\ntype typePlayerMode = typeof PLAYER_MODE_AUDIO | typeof PLAYER_MODE_AJAX | typeof PLAYER_MODE_FETCH;\ntype typeWhereInQueue = typeof WHERE_IN_QUEUE_AT_START | typeof WHERE_IN_QUEUE_AT_END;\n\nexport interface ICoreOptions {\n    volume?: number;\n    loopQueue?: boolean;\n    loopSong?: boolean;\n    soundsBaseUrl?: string;\n    playingProgressIntervalTime?: number;\n    playNextOnEnded?: boolean;\n    stopOnReset?: boolean;\n    visibilityAutoMute?: boolean;\n    createAudioContextOnFirstUserInteraction?: boolean;\n    persistVolume?: boolean;\n    loadPlayerMode?: typePlayerMode;\n    audioContext?: AudioContext;\n    addAudioElementsToDom?: boolean;\n}\n\nexport interface ISoundsQueueOptions {\n    soundAttributes: ISoundAttributes;\n    whereInQueue?: typeWhereInQueue;\n}\n\ninterface IDecodeSoundOptions {\n    sound: ISound;\n}\n\nexport interface IPlayOptions {\n    whichSound?: number | string | undefined;\n    playTimeOffset?: number;\n}\n\ninterface IFindSoundById {\n    soundId: string | number;\n}\n\ninterface IFindBestSourceResponse {\n    url: string;\n    codec?: string;\n}\n\ninterface IGetSoundFromQueue {\n    whichSound?: string | number;\n    updateIndex?: boolean;\n}\n\ninterface IBestSource {\n    url: string;\n    codec?: string;\n}\n\nexport class PlayerCore {\n\n    // the sounds queue\n    protected _queue: ISound[];\n    // the queue index of the current sound\n    protected _currentIndex: number;\n    // instance of the audio library class\n    protected _playerAudio: PlayerAudio;\n    // playing progress animation frame request id\n    protected _playingProgressRequestId: number = null;\n    // time in milliseconds\n    protected _playingProgressPreviousTimestamp: DOMHighResTimeStamp;\n    // value of the volume before we muted\n    protected _postMuteVolume: number = null;\n    // user player options\n    protected _options: ICoreOptions;\n\n    // constants\n    static readonly WHERE_IN_QUEUE_AT_END = 'append';\n    static readonly WHERE_IN_QUEUE_AT_START = 'prepend';\n\n    static readonly PLAY_SOUND_NEXT = 'next';\n    static readonly PLAY_SOUND_PREVIOUS = 'previous';\n    static readonly PLAY_SOUND_FIRST = 'first';\n    static readonly PLAY_SOUND_LAST = 'last';\n\n    static readonly CURRENT_SOUND = 'current';\n\n    static readonly PLAYER_MODE_AUDIO = 'player_mode_audio';\n    static readonly PLAYER_MODE_AJAX = 'player_mode_ajax';\n    static readonly PLAYER_MODE_FETCH = 'player_mode_fetch';\n\n    constructor(playerOptions: ICoreOptions = {}) {\n\n        const defaultOptions: ICoreOptions = {\n            volume: 80,\n            loopQueue: false,\n            loopSong: false,\n            soundsBaseUrl: '',\n            playingProgressIntervalTime: 200,\n            playNextOnEnded: true,\n            stopOnReset: true,\n            visibilityAutoMute: false,\n            createAudioContextOnFirstUserInteraction: true,\n            persistVolume: true,\n            loadPlayerMode: PLAYER_MODE_AUDIO,\n            audioContext: null,\n            addAudioElementsToDom: false,\n        };\n\n        const options = Object.assign({}, defaultOptions, playerOptions);\n\n        this._queue = [];\n        this._currentIndex = 0;\n        this._options = options;\n        this._playingProgressPreviousTimestamp = 0;\n\n        this._initialize();\n\n    }\n\n    protected _initialize(): void {\n\n        const audioOptions = this._audioOptions();\n\n        // player audio library instance\n        this._playerAudio = new PlayerAudio(audioOptions);\n\n        switch (this._options.loadPlayerMode) {\n            case PlayerCore.PLAYER_MODE_AUDIO:\n                if (!this._playerAudio.detectAudioContextSupport()) {\n                    throw new Error('audio context is not supported by this device');\n                }\n                if (!this._playerAudio.detectAudioElementSupport()) {\n                    throw new Error('audio element is not supported by this device');\n                }\n                break;\n            case PlayerCore.PLAYER_MODE_AJAX:\n                if (!this._playerAudio.detectAudioContextSupport()) {\n                    throw new Error('audio context is not supported by this device');\n                }\n                break;\n        }\n\n    }\n\n    protected _audioOptions(): IAudioOptions {\n\n        const audioOptions: IAudioOptions = {\n            audioContext: this._options.audioContext,\n            createAudioContextOnFirstUserInteraction: this._options.createAudioContextOnFirstUserInteraction,\n            volume: this._options.volume,\n            persistVolume: this._options.persistVolume,\n            loadPlayerMode: this._options.loadPlayerMode,\n            addAudioElementsToDom: this._options.addAudioElementsToDom,\n        };\n\n        return audioOptions;\n\n    }\n\n    public addSoundToQueue({ soundAttributes, whereInQueue = WHERE_IN_QUEUE_AT_END }: ISoundsQueueOptions): ISound {\n\n        const sound: ISound = new PlayerSound(soundAttributes);\n\n        switch (whereInQueue) {\n            case PlayerCore.WHERE_IN_QUEUE_AT_END:\n                this._appendSoundToQueue(sound);\n                break;\n            case PlayerCore.WHERE_IN_QUEUE_AT_START:\n                this._prependSoundToQueue(sound);\n                break;\n        }\n\n        return sound;\n\n    }\n\n    protected _appendSoundToQueue(sound: ISound): void {\n\n        this._queue.push(sound);\n\n    }\n\n    protected _prependSoundToQueue(sound: ISound): void {\n\n        this._queue.unshift(sound);\n\n    }\n\n    public async resetQueue(): Promise<void> {\n\n        // check if sound should be stopped on reset\n        if (this._options.stopOnReset) {\n            await this.stop();\n        }\n\n        this._queue.forEach((sound) => {\n            this._playerAudio.disconnectSound(sound);\n        });\n\n        this._queue = [];\n\n    }\n\n    public reset(): void {\n\n        this.resetQueue().catch((error) => {\n            console.error(error);\n        });\n\n    }\n\n    public getQueue(): ISound[] {\n\n        return this._queue;\n\n    }\n\n    public setVolume(volume: number): void {\n\n        this._playerAudio.setVolume(volume).catch((error) => {\n            console.error(error);\n        })\n\n    }\n\n    public getVolume(): number {\n\n        return this._playerAudio.getVolume();\n\n    }\n\n    public setLoopQueue(loppQueue: boolean): void {\n\n        this._options.loopQueue = loppQueue;\n\n    }\n\n    public getLoopQueue(): boolean {\n\n        return this._options.loopQueue;\n\n    }\n\n    public mute(): void {\n\n        const currentVolume = this.getVolume();\n\n        this._playerAudio.setVolume(0, false).catch((error) => {\n            console.error(error);\n        })\n\n        this._postMuteVolume = currentVolume;\n\n    }\n\n    public unMute(): void {\n\n        this._playerAudio.setVolume(this._postMuteVolume, false).catch((error) => {\n            console.error(error);\n        })\n\n        this._postMuteVolume = null;\n\n    }\n\n    public isMuted(): boolean {\n\n        return this._postMuteVolume === null ? false : true;\n\n    }\n\n    public async setPosition(soundPositionInPercent: number): Promise<void> {\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        if (currentSound !== null) {\n\n            let duration = currentSound.getDuration();\n\n            // if the duration did not get set manually or is not a number\n            if (duration === null || isNaN(duration)) {\n\n                // the user can set the sound duration manually but if he didn't the sound\n                // needs to get loaded first, to be able to know the duration it has\n                await this._loadSound(currentSound);\n\n                duration = currentSound.getDuration();\n\n            }\n\n            // calculate the position in seconds\n            const soundPositionInSeconds = (duration / 100) * soundPositionInPercent;\n\n            this.setPositionInSeconds(soundPositionInSeconds);\n\n        }\n\n    }\n\n    public async setPositionInSeconds(soundPositionInSeconds: number): Promise<void> {\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        // if there is a sound currently being played\n        if (currentSound !== null) {\n\n            if (currentSound.onSeeking !== null) {\n\n                const playTime = soundPositionInSeconds;\n                const duration = currentSound.getDuration();\n                const seekingPercentageRaw = (playTime / duration) * 100;\n                const seekingPercentage = Math.round(seekingPercentageRaw);\n\n                currentSound.onSeeking(seekingPercentage, duration, playTime);\n\n            }\n\n            // is the sound is being played\n            if (currentSound.state === PlayerSound.SOUND_STATE_PLAYING) {\n\n                currentSound.playTime = soundPositionInSeconds;\n\n                if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AJAX) {\n                    currentSound.elapsedPlayTime = soundPositionInSeconds;\n                    await this._stop(currentSound, PlayerSound.SOUND_STATE_SEEKING);\n                } else if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AUDIO) {\n                    currentSound.state = PlayerSound.SOUND_STATE_SEEKING;\n                    await this._play(currentSound);\n                }\n\n            } else {\n\n                // only set the sound position but don't play\n                currentSound.playTime = soundPositionInSeconds;\n                currentSound.state = PlayerSound.SOUND_STATE_SEEKING;\n\n            }\n\n        }\n\n    }\n\n    protected async _loadSound(sound: ISound): Promise<void> {\n\n        switch (this._options.loadPlayerMode) {\n            case PlayerCore.PLAYER_MODE_AUDIO:\n                await this._loadSoundUsingAudioElement(sound);\n                break;\n            case PlayerCore.PLAYER_MODE_AJAX:\n                await this._loadSoundUsingRequest(sound);\n                break;\n            case PlayerCore.PLAYER_MODE_FETCH:\n                // TODO: implement fetch (?)\n                console.warn(PlayerCore.PLAYER_MODE_FETCH + ' is not implemented yet');\n        }\n\n    }\n\n    protected _loadSoundUsingAudioElement(sound: ISound): Promise<void> {\n\n        return new Promise((resolve, reject) => {\n\n            // extract the url and codec from sources\n            const { url, codec = null } = this._findBestSource(sound.source);\n\n            sound.url = url;\n            sound.codec = codec;\n\n            if (sound.url !== null) {\n\n                sound.audioElement = this._playerAudio.getAudioElement();\n\n                const canPlayThroughHandler = async () => {\n\n                    // we don't need the listener anymore\n                    sound.audioElement.removeEventListener('canplaythrough', canPlayThroughHandler);\n                    // call onready callback\n                    sound.isReadyToPLay = true;\n                    // duration should now be available\n                    if (!isNaN(sound.audioElement.duration)) {\n                        sound.duration = sound.audioElement.duration;\n                    }\n\n                    resolve();\n\n                }\n\n                sound.audioElement.addEventListener('canplaythrough', canPlayThroughHandler);\n\n                // loading progress\n                // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/progress_event\n                sound.audioElement.onprogress = () => {\n\n                    if (sound.audioElement.buffered.length) {\n\n                        const duration = sound.getDuration()\n                        const buffered = sound.audioElement.buffered.end(0)\n                        const loadingPercentageRaw = 100 / (duration / buffered);\n                        const loadingPercentage = Math.round(loadingPercentageRaw);\n\n                        sound.loadingProgress = loadingPercentage;\n\n                        if (sound.onLoading !== null) {\n                            sound.onLoading(loadingPercentage, duration, buffered);\n                        }\n\n                        sound.duration = sound.audioElement.duration;\n\n                        if (loadingPercentage === 100) {\n                            sound.isBuffering = false;\n                            sound.isBuffered = true;\n                            sound.audioBufferDate = new Date();\n                        }\n\n                    }\n\n                }\n\n                // in chrome you will get this error message in the console:\n                // \"MediaElementAudioSource outputs zeroes due to CORS access restrictions\"\n                // to fix this put crossOrigin to anonymous or change the cors\n                // Access-Control-Allow-Origin header of the server to *\n                // \"crossOrigin\" has to be set before \"src\"\n                sound.audioElement.crossOrigin = 'anonymous';\n\n                sound.audioElement.src = sound.url;\n\n                // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/load\n                sound.audioElement.load();\n\n            } else {\n\n                reject(new Error('sound has no url'));\n\n            }\n\n        });\n\n    }\n\n    protected async _loadSoundUsingRequest(sound: ISound): Promise<void> {\n\n\n        // check for audio buffer before array buffer, because if one exist the other\n        // should exist too and is better for performance to reuse audio buffer then\n        // to redecode array buffer into an audio buffer\n        // user provided audio buffer\n        // decoding an array buffer is an expensive task even on modern hardware\n        // TODO: commented out for now, there is a weird bug when reusing the\n        // audio buffer, somehow the onended callback gets triggered in a loop\n        /*if (sound.audioBuffer !== null) {\n            return;\n        }*/\n\n        // user provided array buffer\n        if (sound.arrayBuffer !== null) {\n            return await this._decodeSound({ sound });\n        }\n\n        // extract the url and codec from sources\n        const { url, codec = null } = this._findBestSource(sound.source);\n\n        sound.url = url;\n        sound.codec = codec;\n\n        if (sound.url !== null) {\n\n            const request = new PlayerRequest();\n\n            // change buffering state\n            sound.isBuffering = true;\n\n            const arrayBuffer = await request.getArrayBuffer(sound);\n\n            sound.arrayBuffer = arrayBuffer;\n\n            await this._decodeSound({ sound });\n\n        } else {\n\n            throw new Error('sound has no url');\n\n        }\n\n    }\n\n    protected async _decodeSound({ sound }: IDecodeSoundOptions): Promise<void> {\n\n        // make a copy of the array buffer first\n        // because the decoding will detach the array buffer\n        // https://github.com/WebAudio/web-audio-api/issues/1175\n        const arrayBufferCopy = sound.arrayBuffer.slice(0);\n\n        const audioBuffer = await this._playerAudio.decodeAudio(arrayBufferCopy);\n\n        sound.audioBuffer = audioBuffer;\n        sound.isBuffering = false;\n        sound.isBuffered = true;\n        sound.audioBufferDate = new Date();\n        sound.duration = audioBuffer.duration;\n        sound.isReadyToPLay = true;\n\n    }\n\n    public async play({ whichSound, playTimeOffset }: IPlayOptions = {}): Promise<ISound> {\n\n        await this._playerAudio.unlockAudio();\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        // whichSound is optional, if set it can be the sound id (string or number)\n        // or it can be these 4 constants: PLAY_SOUND_NEXT, PLAY_SOUND_PREVIOUS,\n        // PLAY_SOUND_FIRST, PLAY_SOUND_LAST\n        const sound = this._getSoundFromQueue({ whichSound, updateIndex: true });\n\n        // if there is no sound we could play, do nothing\n        if (sound === null) {\n            console.warn('no more sounds in array');\n            return sound;\n        }\n\n        // if there is a sound currently being played\n        // AND the current sound is the same sound as the one that will now be played\n        // PAUSE the current sound\n        if (\n            currentSound !== null\n            && (currentSound.state === PlayerSound.SOUND_STATE_PLAYING)\n            && (currentSound.id === sound.id)\n        ) {\n            if (!isNaN(playTimeOffset)) {\n                // sound is already playing but a playTimeOffset got set\n                // so we just need to seek\n                this.setPositionInSeconds(playTimeOffset);\n                return sound;\n            } else {\n                // sound is already playing, do nothing\n                return sound;\n            }\n        }\n\n        // if there is a sound currently being played OR paused\n        // AND the current sound is NOT the same sound as the one that will now be played\n        // STOP the current sound\n        if (\n            currentSound !== null\n            && (currentSound.state === PlayerSound.SOUND_STATE_PLAYING || currentSound.state === PlayerSound.SOUND_STATE_PAUSED)\n            && (currentSound.id !== sound.id)\n        ) {\n            await this._stop(currentSound, PlayerSound.SOUND_STATE_STOPPED);\n        }\n\n        // if the user wants to play the sound from a certain position\n        // then playTimeOffset should be a number and not undefined\n        if (!isNaN(playTimeOffset)) {\n            sound.playTimeOffset = playTimeOffset;\n        } else {\n            sound.playTimeOffset = 0;\n        }\n\n        if (sound.sourceNode === null) {\n            // connect the source to the graph node(s)\n            await this._playerAudio.connectSound(sound, () => {\n                this._onEnded();\n            });\n        }\n\n        // has the sound already been loaded?\n        if (!sound.isReadyToPLay) {\n\n            await this._loadSound(sound);\n\n            await this._play(sound);\n\n        } else {\n\n            await this._play(sound);\n\n        }\n\n        return sound;\n\n    }\n\n    protected async _play(sound: ISound): Promise<void> {\n\n        if (this._playerAudio.isAudioContextFrozen()) {\n            await this._playerAudio.unfreezeAudioContext();\n        }\n\n        if (sound.playTimeOffset > 0) {\n            sound.playTime = sound.playTimeOffset;\n        }\n\n        // start playing\n        if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AJAX) {\n            await this._playAudioBuffer(sound);\n        } else if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AUDIO) {\n            await this._playMediaElementAudio(sound);\n        }\n\n        // state is now playing\n        sound.state = PlayerSound.SOUND_STATE_PLAYING;\n\n        this._triggerSoundCallbacks(sound);\n\n    }\n\n    protected async _playAudioBuffer(sound: ISound): Promise<void> {\n\n        // AudioBufferSourceNode type guard\n        if (sound.sourceNode instanceof AudioBufferSourceNode) {\n\n            // on play, seek, pause, always reset the sound startTime (current context time)\n            sound.startTime = sound.sourceNode.context.currentTime;\n\n            // add the audio buffer to the source node\n            sound.sourceNode.buffer = sound.audioBuffer;\n\n            // start playback\n            // start(when, offset, duration)\n            try {\n                if (sound.state === PlayerSound.SOUND_STATE_SEEKING) {\n                    sound.sourceNode.start(0, sound.playTime);\n                } else if (sound.state === PlayerSound.SOUND_STATE_PAUSED && sound.playTimeOffset === 0) {\n                    sound.sourceNode.start(0, sound.playTime);\n                } else {\n                    if (sound.playTimeOffset > 0) {\n                        sound.elapsedPlayTime = sound.playTimeOffset;\n                        sound.sourceNode.start(0, sound.playTimeOffset);\n                    } else {\n                        sound.sourceNode.start();\n                    }\n                }\n            } catch (error) {\n                throw new Error(error);\n            }\n        }\n\n    }\n\n    protected async _playMediaElementAudio(sound: ISound): Promise<void> {\n\n        // MediaElementAudioSourceNode type guard\n        if (sound.sourceNode instanceof MediaElementAudioSourceNode) {\n\n            if (sound.state === PlayerSound.SOUND_STATE_SEEKING) {\n                sound.audioElement.currentTime = sound.playTime;\n            } else if (sound.state === PlayerSound.SOUND_STATE_PAUSED && sound.playTimeOffset === 0) {\n                sound.audioElement.currentTime = sound.playTime;\n            } else {\n                // if an offset is defined use to play from a defined position\n                if (sound.playTimeOffset > 0) {\n                    sound.audioElement.currentTime = sound.playTimeOffset;\n                } else {\n                    sound.audioElement.currentTime = 0;\n                }\n            }\n\n            await sound.audioElement.play();\n\n        }\n\n    }\n\n    protected _triggerSoundCallbacks(sound: ISound) {\n\n        // if there is an onResumed callback for the sound, trigger it\n        if (sound.onResumed !== null && !sound.firstTimePlayed) {\n            sound.onResumed(sound.playTime);\n        }\n\n        // if there is an onStarted callback for the sound, trigger it\n        if (sound.onStarted !== null && sound.firstTimePlayed) {\n            sound.firstTimePlayed = false;\n            sound.onStarted(sound.playTimeOffset);\n        }\n\n        // if there is an onPlaying callback for the sound, trigger it\n        if (sound.onPlaying !== null) {\n            // reset progress timestamp\n            this._playingProgressPreviousTimestamp = 0;\n            // on request animation frame callback set playing progress\n            // request animation frame callback has a argument, which\n            // is the timestamp when the callback gets called\n            this._progressTrigger(sound, 0);\n        } else {\n            this._playingProgressRequestId = null;\n        }\n\n        return;\n\n    }\n\n    protected _progressTrigger = (sound: ISound, timestamp: DOMHighResTimeStamp) => {\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        // I had a lot of trouble cancelling the animation frame\n        // this is why I added this check\n        // often onended would get called by even though I do\n        // a cancel in _stop() the animation frame would still repeat\n        if (sound.id !== currentSound.id || currentSound.state !== PlayerSound.SOUND_STATE_PLAYING) {\n            return;\n        }\n\n        // throttle requests to not more than once every 200ms \n        if ((timestamp - this._playingProgressPreviousTimestamp) >= this._options.playingProgressIntervalTime) {\n\n            const currentTime = sound.getCurrentTime();\n            const duration = sound.getDuration();\n\n            if (!isNaN(currentTime) && !isNaN(duration)) {\n\n                let playingPercentage = 0;\n\n                if (currentTime !== 0) {\n                    const playingPercentageRaw = (currentTime / duration) * 100;\n                    playingPercentage = Math.round(playingPercentageRaw);\n                }\n\n                sound.playedTimePercentage = playingPercentage;\n                sound.playTime = currentTime;\n\n                // execute playing progress callback\n                sound.onPlaying(playingPercentage, duration, currentTime);\n\n                this._playingProgressPreviousTimestamp = timestamp;\n            }\n\n        }\n\n        // request animation frame loop\n        this._playingProgressRequestId = window.requestAnimationFrame((timestamp) => {\n            this._progressTrigger(sound, timestamp);\n        });\n\n    }\n\n    protected async _onEnded(): Promise<void> {\n\n        if (this._options.playNextOnEnded) {\n\n            const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n            if (currentSound !== null) {\n\n                // when we set the sound to paused...\n                // audio buffer will trigger onEnded because we actually stop the song\n                // audio element will not trigger onEnded as we pause the song\n                // this is why, for audio buffer (ajax) sounds we check if they have\n                // the playing state before triggering the next sound\n                // if stopped, seeking or pause we do nothing\n                if (\n                    this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AUDIO ||\n                    (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AJAX && currentSound.state === PlayerSound.SOUND_STATE_PLAYING)\n                ) {\n\n                    const nextSound = this._getSoundFromQueue({ whichSound: PlayerCore.PLAY_SOUND_NEXT });\n\n                    let willPlayNext = false;\n\n                    // check if there is another sound in the queue\n                    if (nextSound !== null) {\n                        willPlayNext = true;\n                    }\n\n                    if (!willPlayNext) {\n                        await this._playerAudio.freezeAudioContext();\n                    }\n\n                    if (currentSound.onEnded !== null) {\n                        currentSound.onEnded(willPlayNext);\n                    }\n\n                    try {\n                        await this.next();\n                    } catch (error) {\n                        console.error(error)\n                    }\n\n                }\n\n                if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AJAX && currentSound.state === PlayerSound.SOUND_STATE_SEEKING) {\n                    try {\n                        // audio buffer source nodes get destroyed on stop\n                        // this is why in ajax mode we need to do a fresh start when seeking\n                        await this.play(currentSound);\n                    } catch (error) {\n                        console.error(error)\n                    }\n                }\n\n            }\n\n        }\n\n    }\n\n    protected _getSoundFromQueue({ whichSound, updateIndex = false }: IGetSoundFromQueue = {}): ISound {\n\n        let sound = null;\n        let soundIndex: number = null;\n\n        // check if the queue is empty\n        if (this._queue.length === 0) {\n            return sound;\n        }\n\n        // if which sound to play did not get specified\n        // we set it to the current sound by default\n        if (typeof whichSound === 'undefined') {\n            whichSound = PlayerCore.CURRENT_SOUND;\n        }\n\n        // if which sound to play is a constant\n        switch (whichSound) {\n            case PlayerCore.CURRENT_SOUND:\n                soundIndex = this._currentIndex\n                sound = this._queue[soundIndex];\n                break;\n            case PlayerCore.PLAY_SOUND_NEXT:\n                if (this._queue[this._currentIndex + 1] !== undefined) {\n                    soundIndex = this._currentIndex + 1;\n                    sound = this._queue[soundIndex];\n                } else if (this._options.loopQueue) {\n                    // if last sound is playing and loop is enabled\n                    // on next we jump to first sound\n                    soundIndex = 0;\n                    sound = this._queue[soundIndex];\n                }\n                break;\n            case PlayerCore.PLAY_SOUND_PREVIOUS:\n                if (this._queue[this._currentIndex - 1] !== undefined) {\n                    soundIndex = this._currentIndex - 1;\n                    sound = this._queue[soundIndex];\n                } else if (this._options.loopQueue) {\n                    // if first sound is playing and loop is enabled\n                    // on previous we jump to last sound\n                    soundIndex = this._queue.length - 1;\n                    sound = this._queue[soundIndex];\n                }\n                break;\n            case PlayerCore.PLAY_SOUND_FIRST:\n                if (this._queue.length > 0) {\n                    soundIndex = 0;\n                    sound = this._queue[soundIndex];\n                }\n                break;\n            case PlayerCore.PLAY_SOUND_LAST:\n                if (this._queue.length > 0) {\n                    soundIndex = this._queue.length - 1;\n                    sound = this._queue[soundIndex];\n                }\n                break;\n            default:\n                // if \"which sound to play\" (soundId) is a string or number\n                [sound, soundIndex] = this._findSoundById({ soundId: whichSound });\n        }\n\n        if (soundIndex !== null && updateIndex) {\n            this._currentIndex = soundIndex;\n        }\n\n        return sound;\n\n    }\n\n    protected _findSoundById({ soundId }: IFindSoundById): [ISound, number] {\n\n        let sound: ISound = null;\n        let soundIndex = 0;\n\n        this._queue.some((soundFromQueue, index) => {\n\n            if (soundFromQueue.id === soundId) {\n                sound = soundFromQueue;\n                soundIndex = index;\n                return true;\n            }\n\n        });\n\n        return [sound, soundIndex];\n\n    }\n\n    protected _findBestSource(soundSource: (ISoundSource)[] | ISoundSource): IFindBestSourceResponse {\n\n        const bestSource: IBestSource = {\n            url: null,\n            codec: null\n        };\n\n        let sources: (ISoundSource)[];\n\n        // if the source is not an array but a single source object\n        // we first transform it into an array\n        if (!Array.isArray(soundSource)) {\n            sources = [soundSource];\n        } else {\n            sources = soundSource;\n        }\n\n        let i = 0;\n\n        while (i < sources.length) {\n\n            const source = sources[i]\n            let soundUrl = '';\n\n            // if the player had as option a baseUrl for sounds add it now\n            if (this._options.soundsBaseUrl !== '') {\n                soundUrl = this._options.soundsBaseUrl;\n            }\n\n            soundUrl += source.url;\n\n            // check if the codec (if any got specified) is supported\n            // by the device\n            let isCodecSupported = true;\n\n            if (source.codec !== null) {\n                isCodecSupported = this._checkCodecSupport(source.codec);\n            }\n\n            // only if the codec of the source is supported\n            if (isCodecSupported) {\n\n                if (source.isPreferred) {\n                    // if multiple sources but this one if preferred and if previous\n                    // sources also had a supported codec we still overwrite the\n                    // previous match\n                    bestSource.url = soundUrl;\n                    bestSource.codec = source.codec;\n                    // so the source is preferred and supported so we can exit early\n                    break;\n                } else {\n                    // if no best source has been found so far, we don't\n                    // care if it's preferred it's automatically chosen\n                    // as best\n                    bestSource.url = soundUrl;\n                    bestSource.codec = source.codec;\n                    // source is supported, but maybe there is preferred & supported\n                    // so we don't exit the loop just yet\n                }\n\n            }\n\n            i++;\n\n        }\n\n        return bestSource;\n\n    }\n\n    protected _checkCodecSupport(codec: string): boolean {\n\n        let mediaMimeTypes: string[];\n        let error = '';\n\n        switch (codec) {\n            case 'ogg':\n                mediaMimeTypes = ['audio/ogg; codecs=\"vorbis\"'];\n                break;\n            case 'oga':\n                mediaMimeTypes = ['audio/ogg; codecs=\"vorbis\"'];\n                break;\n            case 'mp3':\n                mediaMimeTypes = ['audio/mpeg; codecs=\"mp3\"'];\n                break;\n            case 'opus':\n                mediaMimeTypes = ['audio/ogg; codecs=\"opus\"', 'audio/webm; codecs=\"opus\"'];\n                break;\n            case 'wav':\n                mediaMimeTypes = ['audio/wav; codecs=\"1\"'];\n                break;\n            case 'm4a':\n                mediaMimeTypes = ['audio/m4a;', 'audio/x-m4a;'];\n                break;\n            case 'm4p':\n                mediaMimeTypes = ['audio/m4p;', 'audio/x-m4p;'];\n                break;\n            case 'caf':\n                mediaMimeTypes = ['audio/x-caf;'];\n                break;\n            case 'aac':\n                mediaMimeTypes = ['audio/aac;'];\n                break;\n            case 'weba':\n            case 'webm':\n                mediaMimeTypes = ['audio/webm; codecs=\"vorbis\"'];\n                break;\n            case 'flac':\n                mediaMimeTypes = ['audio/flac;', 'audio/x-flac;'];\n                break;\n            default:\n                error = 'unrecognised codec';\n                break;\n        }\n\n        if (error) {\n            throw new Error(error);\n        }\n\n        return this._checkMimeTypesSupport(mediaMimeTypes);\n\n    }\n\n    protected _checkMimeTypesSupport(mediaMimeTypes: string[]): boolean {\n\n        const deviceAudio = new Audio();\n\n        let isSupported = false;\n\n        mediaMimeTypes.forEach((mediaMimeType) => {\n\n            const isMediaTypeSupported: string = deviceAudio.canPlayType(mediaMimeType).replace(/^no$/, '');\n\n            if (isMediaTypeSupported) {\n                isSupported = true;\n            }\n\n        });\n\n        return isSupported;\n\n    }\n\n    public async pause(): Promise<ISound> {\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        if (currentSound === null) {\n            return;\n        }\n\n        if (currentSound.state === PlayerSound.SOUND_STATE_PAUSED) {\n            return;\n        }\n\n        const currentTime = currentSound.getCurrentTime();\n\n        currentSound.playTime = currentTime;\n\n        if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AJAX) {\n            currentSound.elapsedPlayTime = currentTime;\n        }\n\n        // trigger onpaused callback\n        if (currentSound.onPaused !== null) {\n            currentSound.onPaused(currentSound.playTime);\n        }\n\n        await this._stop(currentSound, PlayerSound.SOUND_STATE_PAUSED);\n\n        return currentSound;\n\n    }\n\n    public async stop(): Promise<ISound> {\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        if (currentSound === null) {\n            return;\n        }\n\n        // check if sound is already stopped\n        if (currentSound.state === PlayerSound.SOUND_STATE_STOPPED) {\n            return;\n        }\n\n        // freeze the audio context\n        await this._playerAudio.freezeAudioContext();\n\n        // trigger stopped callback\n        if (currentSound.onStopped !== null) {\n            currentSound.onStopped(currentSound.playTime);\n        }\n\n        await this._stop(currentSound, PlayerSound.SOUND_STATE_STOPPED);\n\n        return currentSound;\n\n    }\n\n    protected async _stop(sound: ISound, soundState: typeSoundStates): Promise<void> {\n\n        if (this._playingProgressRequestId !== null) {\n            cancelAnimationFrame(this._playingProgressRequestId);\n            this._playingProgressRequestId = null;\n        }\n\n        sound.state = soundState;\n\n        if (sound.sourceNode !== null) {\n\n            if (sound.sourceNode instanceof AudioBufferSourceNode) {\n                // if using the AudioBufferSourceNode use the stop method\n                sound.sourceNode.stop(0);\n                // the audio buffer can be reused for multiple plays\n                // however the audio buffer source can not\n                await this._playerAudio.disconnectSound(sound);\n            }\n\n            if (sound.sourceNode instanceof MediaElementAudioSourceNode) {\n                // if using the MediaElementAudioSourceNode use the pause method\n                sound.audioElement.pause();\n            }\n\n        }\n\n        // if it is fully stopped, not just paused\n        if (soundState === PlayerSound.SOUND_STATE_STOPPED) {\n            // reset sound values\n            sound.isReadyToPLay = false;\n            sound.firstTimePlayed = true;\n            sound.startTime = 0;\n            sound.elapsedPlayTime = 0;\n            sound.playTime = 0;\n            sound.playedTimePercentage = 0;\n            // disconnect the sound\n            await this._playerAudio.disconnectSound(sound);\n        }\n\n    }\n\n    public async next(): Promise<ISound> {\n\n        // alias for play next\n        return await this.play({ whichSound: PlayerCore.PLAY_SOUND_NEXT });\n\n    }\n\n    public async previous(): Promise<ISound> {\n\n        // alias for play previous\n        return await this.play({ whichSound: PlayerCore.PLAY_SOUND_PREVIOUS });\n\n    }\n\n    public async first(): Promise<ISound> {\n\n        // alias for play first\n        return await this.play({ whichSound: PlayerCore.PLAY_SOUND_FIRST });\n\n    }\n\n    public async last(): Promise<ISound> {\n\n        // alias for play last\n        return await this.play({ whichSound: PlayerCore.PLAY_SOUND_LAST });\n\n    }\n\n    public setVisibilityAutoMute(visibilityAutoMute: boolean): void {\n\n        this._options.visibilityAutoMute = visibilityAutoMute;\n\n        if (visibilityAutoMute) {\n            document.addEventListener('visibilitychange', this._handleVisibilityChange.bind(this), false);\n        } else {\n            document.removeEventListener('visibilitychange', this._handleVisibilityChange.bind(this), false);\n        }\n\n    }\n\n    public getVisibilityAutoMute(): boolean {\n        return this._options.visibilityAutoMute;\n    }\n\n    protected _handleVisibilityChange(): void {\n\n        let hiddenKeyword: string;\n\n        if (typeof document.hidden !== 'undefined') { // Opera 12.10 and Firefox 18 and later support\n            hiddenKeyword = 'hidden';\n\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof (document as any).msHidden !== 'undefined') {\n            hiddenKeyword = 'msHidden';\n\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof (document as any).webkitHidden !== 'undefined') {\n            hiddenKeyword = 'webkitHidden';\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if ((document as any)[hiddenKeyword]) {\n            this.mute();\n        } else {\n            this.unMute();\n        }\n    }\n\n    public async disconnect(): Promise<void> {\n\n        // adding another check here to cancel animation frame because:\n        // a player can be disconnect while song is paused or playing\n        // which means the cancelAnimationFrame in _stop would never get triggered\n        if (this._playingProgressRequestId !== null) {\n            cancelAnimationFrame(this._playingProgressRequestId);\n            this._playingProgressRequestId = null;\n        }\n\n        await this._playerAudio.shutDown(this._queue);\n\n    }\n\n    public async getAudioContext(): Promise<AudioContext> {\n\n        const audioContext = await this._playerAudio.getAudioContext();\n\n        return audioContext;\n\n    }\n\n}\n"],"names":["PlayerSound","constructor","soundAttributes","this","url","codec","loop","sourceNode","gainNode","isReadyToPLay","isBuffered","isBuffering","audioElement","audioBuffer","arrayBuffer","audioBufferDate","playTimeOffset","startTime","elapsedPlayTime","playTime","playedTimePercentage","state","loadingProgress","duration","firstTimePlayed","isConnectToPlayerGain","Array","isArray","source","id","_generateSoundId","onLoading","onPlaying","onStarted","onEnded","onStopped","onPaused","onResumed","onSeeking","ArrayBuffer","AudioBuffer","Date","getDuration","getCurrentTime","currentTime","AudioBufferSourceNode","context","MediaElementAudioSourceNode","Math","round","Number","EPSILON","now","toString","random","substring","SOUND_STATE_STOPPED","SOUND_STATE_PAUSED","SOUND_STATE_PLAYING","SOUND_STATE_SEEKING","PlayerAudio","options","_audioContext","_volume","_audioNodes","_audioElement","_mediaElementAudioSourceNode","_isAudioUnlocked","_options","_initialize","createAudioContextOnFirstUserInteraction","_addFirstUserInteractionEventListeners","getAudioNodes","decodeAudio","audioContext","getAudioContext","decodeAudioData","_createAudioContext","AudioContext","WebAudioContext","window","webkitAudioContext","document","addEventListener","unlockAudio","bind","_removeFirstUserInteractionEventListeners","removeEventListener","Promise","resolve","reject","then","placeholderBuffer","createBuffer","bufferSource","createBufferSource","onended","disconnect","buffer","loadPlayerMode","_createAudioElementAndSource","catch","connect","destination","start","_createAudioElement","_createMediaElementAudioSourceNode","Audio","controls","autoplay","preload","volume","addAudioElementsToDom","body","appendChild","getAudioElement","unfreezeAudioContext","resume","freezeAudioContext","suspend","isAudioContextFrozen","detectAudioContextSupport","audioContextSupported","detectAudioElementSupport","createElement","canPlayType","_createAudioBufferSourceNode","createMediaElementSource","_destroyMediaElementAudioSourceNode","mediaElement","remove","_destroyAudioBufferSourceNode","_destroyAudioContext","close","shutDown","songsQueue","forEach","sound","disconnectSound","_disconnectPlayerGainNode","_getPlayerGainNode","GainNode","createGain","_initializeVolume","connectSound","onEndedCallback","audioBufferSourceNode","gain","value","playerGainNode","_changePlayerGainValue","gainValue","setTargetAtTime","setVolume","forceUpdateUserVolume","persistVolume","localStorage","setItem","newGainValue","getVolume","userVolumeInPercent","parseInt","getItem","isNaN","PlayerRequest","getArrayBuffer","requested","xhr","XMLHttpRequest","open","responseType","onload","status","response","Error","statusText","onprogress","event","loadingPercentageRaw","total","loaded","loadingPercentage","onerror","error","send","PlayerCore","playerOptions","_playingProgressRequestId","_postMuteVolume","_progressTrigger","timestamp","currentSound","_getSoundFromQueue","whichSound","CURRENT_SOUND","_playingProgressPreviousTimestamp","playingProgressIntervalTime","playingPercentage","playingPercentageRaw","requestAnimationFrame","defaultOptions","loopQueue","loopSong","soundsBaseUrl","playNextOnEnded","stopOnReset","visibilityAutoMute","Object","assign","_queue","_currentIndex","audioOptions","_audioOptions","_playerAudio","PLAYER_MODE_AUDIO","PLAYER_MODE_AJAX","addSoundToQueue","whereInQueue","WHERE_IN_QUEUE_AT_END","_appendSoundToQueue","WHERE_IN_QUEUE_AT_START","_prependSoundToQueue","push","unshift","resetQueue","stop","reset","getQueue","setLoopQueue","loppQueue","getLoopQueue","mute","currentVolume","unMute","isMuted","setPosition","soundPositionInPercent","_loadSound","soundPositionInSeconds","setPositionInSeconds","seekingPercentageRaw","seekingPercentage","_stop","_play","_loadSoundUsingAudioElement","_loadSoundUsingRequest","PLAYER_MODE_FETCH","_findBestSource","canPlayThroughHandler","__awaiter","buffered","length","end","crossOrigin","src","load","_decodeSound","request","arrayBufferCopy","slice","play","updateIndex","_onEnded","_playAudioBuffer","_playMediaElementAudio","_triggerSoundCallbacks","willPlayNext","PLAY_SOUND_NEXT","next","soundIndex","undefined","PLAY_SOUND_PREVIOUS","PLAY_SOUND_FIRST","PLAY_SOUND_LAST","_findSoundById","soundId","some","soundFromQueue","index","soundSource","bestSource","sources","i","soundUrl","isCodecSupported","_checkCodecSupport","isPreferred","mediaMimeTypes","_checkMimeTypesSupport","deviceAudio","isSupported","mediaMimeType","replace","pause","soundState","cancelAnimationFrame","previous","first","last","setVisibilityAutoMute","_handleVisibilityChange","getVisibilityAutoMute","hiddenKeyword","hidden","msHidden","webkitHidden"],"mappings":"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"}