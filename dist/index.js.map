{"version":3,"file":"index.js","sources":["../src/library/sound.ts","../src/library/audio.ts","../src/library/request.ts","../src/library/core.ts"],"sourcesContent":["const SOUND_STATE_STOPPED = 'sound_state_stopped';\nconst SOUND_STATE_PAUSED = 'sound_state_paused';\nconst SOUND_STATE_PLAYING = 'sound_state_playing';\nconst SOUND_STATE_SEEKING = 'sound_state_seeking';\n\nexport type typeSoundStates = typeof SOUND_STATE_STOPPED | typeof SOUND_STATE_PAUSED | typeof SOUND_STATE_PLAYING | typeof SOUND_STATE_SEEKING;\n\nexport interface IOnProgress {\n    (playingPercentage: number, duration: number, playTime: number): void;\n}\n\nexport interface IOnEnded {\n    (willPlayNext: boolean): void;\n}\n\nexport interface IOnStarted {\n    (playTimeOffset: number): void;\n}\n\nexport interface IOnPaused {\n    (playTime: number): void;\n}\n\nexport interface IOnResumed {\n    (playTime: number): void;\n}\n\nexport interface IOnStopped {\n    (playTime: number): void;\n}\n\nexport interface IOnSeeking {\n    (seekingPercentage: number, duration: number, playTime: number): void;\n}\n\nexport interface ISoundSource {\n    url: string;\n    codec?: string;\n    isPreferred?: boolean;\n}\n\nexport interface ISoundAttributes {\n    // source(s) are NOT mandatory as user can provide an arrayBuffer\n    // and / or audioBuffer in which case the source url is not needed\n    source?: (ISoundSource)[] | ISoundSource;\n    id?: number | string;\n    loop?: boolean;\n    audioBuffer?: AudioBuffer;\n    arrayBuffer?: ArrayBuffer;\n    duration?: number;\n    seekPercentage?: number;\n\n    // callbacks\n    onLoading?: IOnProgress;\n    onPlaying?: IOnProgress;\n    onEnded?: IOnEnded;\n    onStarted?: IOnStarted;\n    onStopped?: IOnStopped;\n    onPaused?: IOnPaused;\n    onResumed?: IOnResumed;\n    onSeeking?: IOnSeeking;\n}\n\nexport interface ISound extends ISoundAttributes, ISoundSource {\n    // public properties\n    sourceNode: AudioBufferSourceNode | MediaElementAudioSourceNode;\n    gainNode: GainNode;\n    isReadyToPLay: boolean;\n    isBuffered: boolean;\n    isBuffering: boolean;\n    audioElement: HTMLAudioElement;\n    audioBufferDate: Date;\n    playTimeOffset: number;\n    startTime: number;\n    playTime: number;\n    playedTimePercentage: number;\n    state: typeSoundStates;\n    loadingProgress: number;\n    firstTimePlayed: boolean;\n    isConnectToPlayerGain: boolean;\n    durationSetManually: boolean;\n    elapsedPlayTime: number;\n    // methods\n    getCurrentTime(): number;\n    getDuration(): number;\n    setDuration(duration: number): void;\n    setLoop(loop: boolean): void;\n    getLoop(): boolean;\n}\n\nexport class PlayerSound implements ISound {\n\n    // static constants\n    static readonly SOUND_STATE_STOPPED = 'sound_state_stopped';\n    static readonly SOUND_STATE_PAUSED = 'sound_state_paused';\n    static readonly SOUND_STATE_PLAYING = 'sound_state_playing';\n    static readonly SOUND_STATE_SEEKING = 'sound_state_seeking';\n\n    // public properties\n    public source: (ISoundSource)[] | ISoundSource;\n    public url: string = null;\n    public codec: string = null;\n    public id: number | string;\n    public loop: boolean = false;\n    public sourceNode: AudioBufferSourceNode | MediaElementAudioSourceNode = null;\n    public gainNode: GainNode = null;\n    public isReadyToPLay = false;\n    public isBuffered = false;\n    public isBuffering = false;\n    public audioElement: HTMLAudioElement = null;\n    public audioBuffer: AudioBuffer = null;\n    public arrayBuffer: ArrayBuffer = null;\n    public audioBufferDate: Date = null;\n    public playTimeOffset = 0;\n    public startTime = 0;\n    public playTime = 0;\n    public playedTimePercentage = 0;\n    public state: typeSoundStates = SOUND_STATE_STOPPED;\n    public loadingProgress = 0;\n    public duration: number = null;\n    public durationSetManually: boolean = false;\n    public firstTimePlayed = true;\n    public isConnectToPlayerGain = false;\n    // elapsedPlayTime is used to adjust the playtime\n    // when playing audio buffers\n    // on seek, pause or when there is a playTimeOffset\n    // see getCurrentTime function\n    public elapsedPlayTime = 0;\n    // the percentage to seek to\n    public seekPercentage = 0; \n    \n    // callbacks\n    public onLoading: IOnProgress;\n    public onPlaying: IOnProgress;\n    public onEnded: IOnEnded;\n    public onStarted: IOnStarted;\n    public onStopped: IOnStopped;\n    public onPaused: IOnPaused;\n    public onResumed: IOnResumed;\n    public onSeeking?: IOnSeeking;\n\n    constructor(soundAttributes: ISoundAttributes) {\n\n        if (!Array.isArray(soundAttributes.source)) {\n            this.source = [soundAttributes.source];\n        } else {\n            this.source = soundAttributes.source;\n        }\n\n        if (typeof soundAttributes.id !== 'undefined') {\n            this.id = soundAttributes.id;\n        } else {\n            this.id = this._generateSoundId()\n        }\n\n        this.loop = soundAttributes.loop || false;\n\n        this.seekPercentage = soundAttributes.seekPercentage || 0;\n\n        // the user can set the duration manually\n        // this is usefull if we need to convert the position percentage into seconds but don't want to preload the song\n        // to get the duration the song has to get preloaded as the duration is a property of the audioBuffer\n        if (!isNaN(soundAttributes.duration)) {\n            this.duration = soundAttributes.duration;\n            this.durationSetManually = true;\n        }\n\n        if (typeof soundAttributes.onLoading === 'function') {\n            this.onLoading = soundAttributes.onLoading;\n        } else {\n            this.onLoading = null;\n        }\n\n        if (typeof soundAttributes.onPlaying === 'function') {\n            this.onPlaying = soundAttributes.onPlaying;\n        } else {\n            this.onPlaying = null;\n        }\n\n        if (typeof soundAttributes.onStarted === 'function') {\n            this.onStarted = soundAttributes.onStarted;\n        } else {\n            this.onStarted = null;\n        }\n\n        if (typeof soundAttributes.onEnded === 'function') {\n            this.onEnded = soundAttributes.onEnded;\n        } else {\n            this.onEnded = null;\n        }\n\n        if (typeof soundAttributes.onStopped === 'function') {\n            this.onStopped = soundAttributes.onStopped;\n        } else {\n            this.onStopped = null;\n        }\n\n        if (typeof soundAttributes.onPaused === 'function') {\n            this.onPaused = soundAttributes.onPaused;\n        } else {\n            this.onPaused = null;\n        }\n\n        if (typeof soundAttributes.onResumed === 'function') {\n            this.onResumed = soundAttributes.onResumed;\n        } else {\n            this.onResumed = null;\n        }\n\n        if (typeof soundAttributes.onSeeking === 'function') {\n            this.onSeeking = soundAttributes.onSeeking;\n        } else {\n            this.onSeeking = null;\n        }\n\n        if (soundAttributes.arrayBuffer instanceof ArrayBuffer) {\n            this.arrayBuffer = soundAttributes.arrayBuffer;\n        }\n\n        if (soundAttributes.audioBuffer instanceof AudioBuffer) {\n            this.audioBuffer = soundAttributes.audioBuffer;\n            this.isBuffering = false;\n            this.isBuffered = true;\n            this.audioBufferDate = new Date();\n            // only update duration if it did not get set manually\n            if (!this.durationSetManually) {\n                this.duration = this.audioBuffer.duration;\n            }\n        }\n\n    }\n\n    public getCurrentTime(): number {\n\n        let currentTime: number;\n\n        if (this.sourceNode !== null) {\n            if (this.sourceNode instanceof AudioBufferSourceNode) {\n                currentTime = (this.sourceNode.context.currentTime - this.startTime) + this.elapsedPlayTime;\n            } else if (this.sourceNode instanceof MediaElementAudioSourceNode) {\n                currentTime = this.audioElement.currentTime;\n            }\n        }\n\n        return currentTime;\n\n    }\n\n    public getDuration(): number {\n\n        return this.duration;\n\n    }\n\n    public setDuration(duration: number): void {\n\n        if (!isNaN(duration)) {\n            this.duration = duration;\n            this.durationSetManually = true;\n        }\n\n    }\n\n    public setLoop(loop: boolean): void {\n\n        this.loop = loop;\n\n        if (this.state === PlayerSound.SOUND_STATE_PLAYING) {\n\n            if (this.sourceNode !== null) {\n                if (this.sourceNode instanceof AudioBufferSourceNode) {\n                    this.sourceNode.loop = loop;\n                } else if (this.sourceNode instanceof MediaElementAudioSourceNode) {\n                    this.sourceNode.mediaElement.loop = loop;\n                }\n            }\n\n        }\n\n    }\n\n    public getLoop(): boolean {\n\n        return this.loop;\n\n    }\n\n    protected _generateSoundId() {\n\n        return Date.now().toString(36) + Math.random().toString(36).substring(2)\n\n    }\n\n}\n","import { ISound } from './sound';\n\ntype OnEndedCallbackType = (event: Event) => void\n\nexport interface IAudioOptions {\n    audioContext: AudioContext;\n    unlockAudioOnFirstUserInteraction: boolean;\n    volume: number;\n    persistVolume: boolean;\n    loadPlayerMode: string;\n    addAudioElementsToDom: boolean;\n    volumeTransitionTime: number;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/AudioNode\nexport interface IAudioNodes {\n    // https://developer.mozilla.org/en-US/docs/Web/API/GainNode\n    gainNode: GainNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/PannerNode\n    pannerNode?: PannerNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/StereoPannerNode\n    stereoPannerNode?: StereoPannerNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/DelayNode\n    delayNode?: DelayNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ScriptProcessorNode\n    scriptProcessorNode?: ScriptProcessorNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode\n    analyserNode?: AnalyserNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n    biquadFilterNode?: BiquadFilterNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ChannelMergerNode\n    channelMergeNode?: ChannelMergerNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ChannelSplitterNode\n    channelSplitterNode?: ChannelSplitterNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/ConvolverNode\n    convolverNode?: ConvolverNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode\n    dynamicCompressorNode?: DynamicsCompressorNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode\n    oscillatorNode?: OscillatorNode;\n    // https://developer.mozilla.org/en-US/docs/Web/API/WaveShaperNode\n    waveShaperNode?: WaveShaperNode;\n}\n\nexport class PlayerAudio {\n\n    protected _options;\n    protected _audioContext: AudioContext = null;\n    protected _volume: number = null;\n    protected _audioNodes: IAudioNodes = {\n        gainNode: null,\n    };\n    protected _audioElement: HTMLAudioElement = null;\n    protected _mediaElementAudioSourceNode: MediaElementAudioSourceNode = null;\n    protected _isAudioUnlocked: boolean = false;\n    protected _isAudioUnlocking: boolean = false;\n\n    constructor(options: IAudioOptions) {\n\n        this._options = options;\n\n        this._initialize();\n\n    }\n\n    protected _initialize(): void {\n\n        // I was planning on using the \"first user interaction hack\" only (on mobile)\n        // to check if the autoplay policy prevents me from playing a sound\n        // programmatically (without user click)\n        // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getAutoplayPolicy\n        // but this feature is only implemented on firefox (as of 19.09.2023)\n\n        if (this._options.unlockAudioOnFirstUserInteraction) {\n            this._addFirstUserInteractionEventListeners();\n        }\n\n    }\n\n    public getAudioNodes() {\n        return this._audioNodes;\n    }\n\n    public async decodeAudio(arrayBuffer: ArrayBuffer): Promise<AudioBuffer> {\n\n        const audioContext = await this.getAudioContext();\n\n        // Note to self:\n        // the new decodeAudioData returns a promise, older versions accept as second\n        // and third parameter, which are a success and an error callback funtion\n        // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/decodeAudioData\n\n        return await audioContext.decodeAudioData(arrayBuffer);\n\n    }\n\n    protected _createAudioContext(): Promise<void> {\n\n        if (this._audioContext instanceof AudioContext) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const WebAudioContext: typeof AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n\n        // initialize the audio context\n        if (this._options.audioContext !== null) {\n            this._audioContext = this._options.audioContext;\n        } else {\n            this._audioContext = new WebAudioContext();\n        }\n\n    }\n\n    protected _addFirstUserInteractionEventListeners(): void {\n\n        if (this._options.unlockAudioOnFirstUserInteraction) {\n            document.addEventListener('keydown', this.unlockAudio.bind(this));\n            document.addEventListener('mousedown', this.unlockAudio.bind(this));\n            document.addEventListener('pointerdown', this.unlockAudio.bind(this));\n            document.addEventListener('pointerup', this.unlockAudio.bind(this));\n            document.addEventListener('touchend', this.unlockAudio.bind(this));\n        }\n\n    }\n\n    protected _removeFirstUserInteractionEventListeners(): void {\n\n        if (this._options.unlockAudioOnFirstUserInteraction) {\n            document.removeEventListener('keydown', this.unlockAudio.bind(this));\n            document.removeEventListener('mousedown', this.unlockAudio.bind(this));\n            document.removeEventListener('pointerdown', this.unlockAudio.bind(this));\n            document.removeEventListener('pointerup', this.unlockAudio.bind(this));\n            document.removeEventListener('touchend', this.unlockAudio.bind(this));\n        }\n\n    }\n\n    public unlockAudio(): Promise<void> {\n\n        return new Promise((resolve, reject) => {\n\n            if (this._isAudioUnlocking) {\n                return resolve();\n            }\n\n            if (this._isAudioUnlocked) {\n                return resolve();\n            }\n\n            this._isAudioUnlocking = true;\n\n            // it is important to create the audio element before attempting\n            // to play the empty buffer, if creation is done after the\n            // element will get created but as no sound has been played\n            // it will not get unlocked\n            // meaning to unlock an audio element it is not enough to create\n            // one on user interaction but you also need to play a sound\n            if (this._options.loadPlayerMode === 'player_mode_audio') {\n\n                // force the creation to be sure we have a new audio element\n                // and don't use one that got created previously\n                const forceCreate = true;\n\n                // on iOS (mobile) the audio element you want to use needs to have been created\n                // as a direct result of an user interaction\n                // after it got unlocked we re-use that element for all sounds\n                this._createAudioElement(forceCreate).catch((error) => {\n                    console.error(error);\n                    this._isAudioUnlocking = false;\n                    return reject();\n                });\n\n            }\n\n            // make sure the audio context is not suspended\n            // on android this is what unlocks audio\n            this.getAudioContext().then(() => {\n\n                // create an (empty) buffer\n                const placeholderBuffer = this._audioContext.createBuffer(1, 1, 22050);\n\n                // https://developer.mozilla.org/en-US/docs/Web/API/BaseAudioContext/createBufferSource\n                let bufferSource = this._audioContext.createBufferSource();\n\n                bufferSource.onended = () => {\n\n                    bufferSource.disconnect(0);\n\n                    this._removeFirstUserInteractionEventListeners();\n\n                    bufferSource.disconnect(0);\n\n                    bufferSource.buffer = null;\n                    bufferSource = null;\n\n                    this._isAudioUnlocked = true;\n                    this._isAudioUnlocking = false;\n                    return resolve();\n\n                };\n\n                bufferSource.buffer = placeholderBuffer;\n                bufferSource.connect(this._audioContext.destination);\n                // attempt to play the empty buffer to check if there is an error\n                // or if it can be played, in which case audio is unlocked\n                bufferSource.start(0);\n\n            }).catch((error) => {\n                console.error(error);\n                this._isAudioUnlocking = false;\n                return reject();\n            });\n\n        });\n\n    }\n\n    protected async _createAudioElementAndSource(): Promise<void> {\n\n        await this._createAudioElement();\n\n        await this._createMediaElementAudioSourceNode();\n\n    }\n\n    protected async _createAudioElement(forceCreate?: boolean): Promise<void> {\n\n        if (this._audioElement === null || forceCreate === true) {\n\n            const audioElement = new Audio();\n\n            audioElement.controls = false;\n            audioElement.autoplay = false;\n            audioElement.preload = 'auto';\n            audioElement.volume = 1;\n            audioElement.id = 'web-audio-api-player';\n\n            this._audioElement = audioElement;\n\n            if (this._options.addAudioElementsToDom) {\n                document.body.appendChild(audioElement);\n            }\n\n        }\n\n    }\n\n    public async getAudioElement(): Promise<HTMLAudioElement> {\n\n        if (this._audioElement === null) {\n            await this._createAudioElementAndSource();\n        }\n\n        return this._audioElement;\n\n    }\n\n    public async getAudioContext(): Promise<AudioContext> {\n\n        if (this._audioContext === null || this._audioContext.state === 'closed') {\n            await this._createAudioContext();\n        } else if (this._audioContext.state === 'suspended') {\n            await this.unfreezeAudioContext();\n        }\n\n        return this._audioContext;\n\n    }\n\n    public unfreezeAudioContext(): Promise<void> {\n\n        // did resume get implemented\n        if (typeof this._audioContext.resume === 'undefined') {\n\n            // this browser does not support resume\n            // just send back a promise as resume would do\n            return Promise.resolve();\n\n        } else {\n\n            // resume the audio hardware access\n            // audio context resume returns a promise\n            // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/resume\n            return this._audioContext.resume();\n\n        }\n\n    }\n\n    public freezeAudioContext(): Promise<void> {\n\n        // did suspend get implemented\n        if (typeof this._audioContext.suspend === 'undefined') {\n\n            return Promise.resolve();\n\n        } else {\n\n            // halt the audio hardware access temporarily to reduce CPU and battery usage\n            // especially useful on mobile to prevent battery drain\n            return this._audioContext.suspend();\n\n        }\n\n    }\n\n    public isAudioContextFrozen(): boolean {\n\n        return this._audioContext.state === 'suspended' ? true : false;\n\n    }\n\n    public detectAudioContextSupport(): boolean {\n\n        // basic audio context detection\n        let audioContextSupported = false;\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (typeof (window as any).webkitAudioContext !== 'undefined') {\n            audioContextSupported = true;\n        } else if (typeof AudioContext !== 'undefined') {\n            audioContextSupported = true;\n        }\n\n        return audioContextSupported;\n\n    }\n\n    public detectAudioElementSupport(): boolean {\n\n        // basic audio element detection\n        return !!document.createElement('audio').canPlayType;\n\n    }\n\n    protected async _createAudioBufferSourceNode(): Promise<AudioBufferSourceNode> {\n\n        const audioContext = await this.getAudioContext();\n\n        return audioContext.createBufferSource();\n\n    }\n\n    protected async _createMediaElementAudioSourceNode(): Promise<void> {\n\n        if (this._mediaElementAudioSourceNode === null && this._audioElement !== null) {\n\n            const audioContext = await this.getAudioContext();\n\n            // createMediaElementSource: https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createMediaElementSource\n            this._mediaElementAudioSourceNode = audioContext.createMediaElementSource(this._audioElement);\n\n        }\n\n    }\n\n    protected _destroyMediaElementAudioSourceNode(): void {\n\n        if (this._mediaElementAudioSourceNode !== null) {\n\n            if (typeof this._mediaElementAudioSourceNode.mediaElement !== 'undefined') {\n                this._mediaElementAudioSourceNode.mediaElement.remove();\n            }\n\n            this._mediaElementAudioSourceNode.disconnect();\n            this._mediaElementAudioSourceNode = null;\n        }\n\n    }\n\n    protected _destroyAudioBufferSourceNode(): void {\n\n        if (this._mediaElementAudioSourceNode !== null) {\n\n            this._mediaElementAudioSourceNode.disconnect();\n\n        }\n\n    }\n\n    protected async _destroyAudioContext(): Promise<void> {\n\n        if (this._audioContext !== null && this._audioContext.state !== 'closed') {\n            await this._audioContext.close();\n            this._audioContext = null;\n        }\n\n    }\n\n    public async shutDown(songsQueue: ISound[]): Promise<void> {\n\n        this._removeFirstUserInteractionEventListeners();\n\n        songsQueue.forEach((sound) => {\n            this.disconnectSound(sound);\n        });\n\n        this._destroyMediaElementAudioSourceNode();\n        this._destroyAudioBufferSourceNode();\n\n        this._disconnectPlayerGainNode();\n\n        await this._destroyAudioContext();\n\n    }\n\n\n    protected async _getPlayerGainNode(): Promise<GainNode> {\n\n        // the player (master) gain node\n        let gainNode: GainNode;\n\n        if (this._audioNodes.gainNode instanceof GainNode) {\n\n            gainNode = this._audioNodes.gainNode;\n\n        } else {\n\n            const audioContext = await this.getAudioContext();\n\n            // Note: a volume control (GainNode) should always\n            // be the last node that gets connected\n            // so that volume changes take immediate effect\n            gainNode = audioContext.createGain();\n\n            this._initializeVolume(gainNode);\n\n            // final audio graph step: connect the gain node to the audio destination node\n            gainNode.connect(audioContext.destination);\n\n            this._audioNodes.gainNode = gainNode;\n\n        }\n\n        return gainNode;\n\n    }\n\n    protected _disconnectPlayerGainNode(): void {\n\n        if (this._audioNodes.gainNode !== null) {\n            this._audioNodes.gainNode.disconnect();\n            this._audioNodes.gainNode = null;\n        }\n\n    }\n\n    public async connectSound(sound: ISound, onEndedCallback: OnEndedCallbackType): Promise<void> {\n\n        if (sound.isConnectToPlayerGain) {\n            return;\n        }\n\n        if (this._options.loadPlayerMode === 'player_mode_ajax') {\n\n            // get a new audio buffer source node\n            // Note: remember these are \"one use\" only\n            // https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode\n            const audioBufferSourceNode = await this._createAudioBufferSourceNode();\n\n            // create the sound gain node\n            sound.gainNode = audioBufferSourceNode.context.createGain();\n\n            // connect the source to the sound gain node\n            audioBufferSourceNode.connect(sound.gainNode);\n\n            // do we loop this song?\n            audioBufferSourceNode.loop = sound.loop;\n\n            // NOTE: the source nodes onended handler won't have any effect if the loop property\n            // is set to true, as the audio won't stop playing\n            audioBufferSourceNode.onended = onEndedCallback;\n\n            sound.sourceNode = audioBufferSourceNode;\n\n        } else if (this._options.loadPlayerMode === 'player_mode_audio') {\n\n            await this._createAudioElementAndSource();\n\n            // create the sound gain node\n            sound.gainNode = this._mediaElementAudioSourceNode.context.createGain();\n\n            // connect the source to the sound gain node\n            this._mediaElementAudioSourceNode.connect(sound.gainNode);\n\n            // do we loop this song\n            this._mediaElementAudioSourceNode.mediaElement.loop = sound.loop;\n\n            // NOTE: the source nodes onended handler won't have any effect if the loop property\n            // is set to true, as the audio won't stop playing\n            this._mediaElementAudioSourceNode.mediaElement.onended = onEndedCallback;\n\n            sound.sourceNode = this._mediaElementAudioSourceNode;\n\n        }\n\n        // set the gain by default always to 1\n        sound.gainNode.gain.value = 1;\n\n        const playerGainNode = await this._getPlayerGainNode();\n\n        sound.gainNode.connect(playerGainNode);\n        sound.isConnectToPlayerGain = true;\n\n    }\n\n    public async disconnectSound(sound: ISound): Promise<void> {\n\n        if (!sound.isConnectToPlayerGain) {\n            return;\n        }\n\n        if (sound.sourceNode !== null) {\n            sound.sourceNode.disconnect();\n            // we set the source node to null, so that it can get garbage collected\n            // as specified in the specs: you can't reuse an audio buffer source node,\n            // after it got stopped\n            sound.sourceNode = null;\n        }\n\n        if (sound.gainNode !== null) {\n            sound.gainNode.disconnect();\n            sound.gainNode = null;\n            sound.isConnectToPlayerGain = false;\n        }\n\n        if (sound.audioElement !== null) {\n            sound.audioElement = null;\n        }\n\n    }\n\n    protected async _changePlayerGainValue(gainValue: number): Promise<void> {\n\n        if (this._audioNodes.gainNode instanceof GainNode) {\n\n            const audioContext = await this.getAudioContext();\n            const timeConstantInMilliseconds = (!isNaN(this._options.volumeTransitionTime) && this._options.volumeTransitionTime > 0) ? this._options.volumeTransitionTime : 100\n            const timeConstantInSeconds = timeConstantInMilliseconds / 1000;\n\n            try {\n                this._audioNodes.gainNode.gain.setTargetAtTime(gainValue, audioContext.currentTime, timeConstantInSeconds);\n            } catch (error) {\n                console.error('gainValue: ' + gainValue + ' ' + error)\n            }\n\n        }\n\n    }\n\n    public async setVolume(volume: number, forceUpdateUserVolume = true): Promise<number> {\n\n        // we sometimes change the volume, for a fade in/out or when muting, but\n        // in this cases we don't want to update the user's persisted volume, in\n        // which case forceUpdateUserVolume is false else it would be true\n        if (this._options.persistVolume && forceUpdateUserVolume) {\n            localStorage.setItem('WebAudioAPIPlayerVolume', volume.toString());\n        }\n\n        // the gain values we use range from 0 to 1\n        // so we need to divide the volume (in percent) by 100 to get the gain value\n        const newGainValue = volume / 100;\n\n        if (this._audioNodes.gainNode instanceof GainNode) {\n\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n            const currentGainRounded = Math.round((this._audioNodes.gainNode.gain.value + Number.EPSILON) * 100) / 100;\n\n            // check if the volume changed\n            if (newGainValue !== currentGainRounded) {\n\n                // Note to self: the gain value changes the amplitude of the sound wave\n                // a gain value set to 1 does nothing\n                // values between 0 and 1 reduce the loudness, above 1 they amplify the loudness\n                // negative values work too, but they invert the waveform\n                // so -1 is as loud as 1 but with -1 the waveform is inverted\n                await this._changePlayerGainValue(newGainValue);\n\n            }\n\n        }\n\n        this._volume = volume;\n\n        return volume;\n\n    }\n\n    public getVolume(): number {\n\n        let volume: number;\n\n        // check if volume has already been set\n        if (this._volume !== null) {\n\n            volume = this._volume;\n\n        } else if (this._options.persistVolume) {\n\n            // if persist volume is enabled\n            // check if there already is a user volume in localstorage\n            const userVolumeInPercent = parseInt(localStorage.getItem('WebAudioAPIPlayerVolume'));\n\n            volume = userVolumeInPercent;\n\n        }\n\n        // if still no value, fallback to default options value\n        if (typeof volume === 'undefined' || isNaN(volume)) {\n\n            if (!isNaN(this._options.volume)) {\n                volume = this._options.volume;\n            } else {\n                volume = 80;\n                console.error('player options volume is not a number')\n            }\n            \n        }\n\n        this._volume = volume;\n\n        return volume;\n\n    }\n\n    protected _initializeVolume(gainNode: GainNode): void {\n\n        if (this._options.persistVolume) {\n            // if persist volume is enabled\n            // check if there already is a user volume in localstorage\n            const userVolumeInPercent = parseInt(localStorage.getItem('WebAudioAPIPlayerVolume'));\n            const gainValue = userVolumeInPercent / 100;\n\n            if (!isNaN(userVolumeInPercent)) {\n                gainNode.gain.value = gainValue;\n            }\n\n            this._volume = userVolumeInPercent;\n        }\n\n\n        // if no \"user volume\" got found\n        // take the default options volume\n        if (this._volume === null) {\n            const gainValue = this._options.volume / 100;\n            gainNode.gain.value = gainValue;\n            this._volume = this._options.volume;\n        }\n\n    }\n\n}\n","import { IOnProgress } from './sound';\n\nexport interface IRequested {\n    url: string;\n    loadingProgress: number;\n    onLoading?: IOnProgress;\n}\n\nexport class PlayerRequest {\n\n    public getArrayBuffer(requested: IRequested): Promise<ArrayBuffer> {\n\n        return new Promise(function (resolve, reject) {\n\n            const xhr = new XMLHttpRequest();\n\n            // third parameter is for \"async\", should already be \"true\" by default\n            // but who knows maybe a browser vendor decides to change it\n            // so I prefer to explicitly set it to \"true\" just in case\n            xhr.open('GET', requested.url, true);\n\n            // set the expected response type from the server to arraybuffer\n            xhr.responseType = 'arraybuffer';\n\n            xhr.onload = function (): void {\n\n                // gets called even for example a code 404, so check the status is in the 2xx range\n                if (xhr.status >= 200 && xhr.status <= 299) {\n                    resolve(xhr.response);\n                } else {\n                    // status code is not 2xx, reject with an error\n                    reject(new Error(xhr.statusText + '(status:' + xhr.status + ')'));\n                }\n\n            };\n\n            xhr.onprogress = function (event): void {\n\n                const loadingPercentageRaw = 100 / (event.total / event.loaded);\n                const loadingPercentage = Math.round(loadingPercentageRaw);\n\n                // update value on sound object\n                requested.loadingProgress = loadingPercentage;\n\n                if (requested.onLoading !== null) {\n                    requested.onLoading(loadingPercentage, event.total, event.loaded);\n                }\n\n            };\n\n            // also reject for any kind of network errors\n            xhr.onerror = function (error): void {\n\n                reject(error);\n\n            };\n\n            xhr.send();\n\n        });\n\n    }\n\n}\n","import { PlayerSound, ISound, ISoundAttributes, ISoundSource } from './sound';\nimport {\n    PlayerAudio,\n    IAudioOptions,\n} from './audio';\nimport { PlayerRequest } from './request';\n\nconst PLAYER_MODE_AUDIO = 'player_mode_audio';\nconst PLAYER_MODE_AJAX = 'player_mode_ajax';\nconst PLAYER_MODE_FETCH = 'player_mode_fetch';\n\nconst WHERE_IN_QUEUE_AT_START = 'prepend';\nconst WHERE_IN_QUEUE_AT_END = 'append';\n\nconst AFTER_LOADING_SEEK = 'after_loading_seek';\nconst AFTER_LOADING_PLAY = 'after_loading_play';\n\nconst VISIBILITY_HIDDEN_ACTION_MUTE = 'visibility_hidden_action_mute';\nconst VISIBILITY_HIDDEN_ACTION_PAUSE = 'visibility_hidden_action_pause';\n\ntype typePlayerMode = typeof PLAYER_MODE_AUDIO | typeof PLAYER_MODE_AJAX | typeof PLAYER_MODE_FETCH;\ntype typeWhereInQueue = typeof WHERE_IN_QUEUE_AT_START | typeof WHERE_IN_QUEUE_AT_END;\ntype typeAfterLoadingAction = typeof AFTER_LOADING_SEEK | typeof AFTER_LOADING_PLAY;\ntype typeVisibilityHiddenAction = typeof VISIBILITY_HIDDEN_ACTION_MUTE | typeof VISIBILITY_HIDDEN_ACTION_PAUSE;\n\nexport interface ICoreOptions {\n    volume?: number;\n    loopQueue?: boolean;\n    loopSong?: boolean;\n    soundsBaseUrl?: string;\n    playingProgressIntervalTime?: number;\n    playNextOnEnded?: boolean;\n    stopOnReset?: boolean;\n    visibilityWatch?: boolean;\n    visibilityHiddenAction?: typeVisibilityHiddenAction;\n    unlockAudioOnFirstUserInteraction?: boolean;\n    persistVolume?: boolean;\n    loadPlayerMode?: typePlayerMode;\n    audioContext?: AudioContext;\n    addAudioElementsToDom?: boolean;\n    volumeTransitionTime?: number;\n}\n\nexport interface ISoundsQueueOptions {\n    soundAttributes: ISoundAttributes;\n    whereInQueue?: typeWhereInQueue;\n}\n\nexport interface IPlayOptions {\n    whichSound?: number | string | undefined;\n    playTimeOffset?: number;\n}\n\ninterface IFindSoundById {\n    soundId: string | number;\n}\n\ninterface IFindBestSourceResponse {\n    url: string;\n    codec?: string;\n}\n\ninterface IGetSoundFromQueue {\n    whichSound?: string | number;\n    updateIndex?: boolean;\n}\n\ninterface IBestSource {\n    url: string;\n    codec?: string;\n}\n\nexport class PlayerCore {\n\n    // the sounds queue\n    protected _queue: ISound[];\n    // the queue index of the current sound\n    protected _currentIndex: number;\n    // instance of the audio library class\n    protected _playerAudio: PlayerAudio;\n    // playing progress animation frame request id\n    protected _playingProgressRequestId: number = null;\n    // time in milliseconds\n    protected _playingProgressPreviousTimestamp: DOMHighResTimeStamp;\n    // value of the volume before it got muted\n    protected _postMuteVolume: number = null;\n    // is playing before visibility is hidden event\n    protected _postVisibilityHiddenPlaying: boolean = null;\n    // user player options\n    protected _options: ICoreOptions;\n\n    // constants\n    static readonly WHERE_IN_QUEUE_AT_END = 'append';\n    static readonly WHERE_IN_QUEUE_AT_START = 'prepend';\n\n    static readonly AFTER_LOADING_SEEK = 'after_loading_seek';\n    static readonly AFTER_LOADING_PLAY = 'after_loading_play';\n\n    static readonly PLAY_SOUND_NEXT = 'next';\n    static readonly PLAY_SOUND_PREVIOUS = 'previous';\n    static readonly PLAY_SOUND_FIRST = 'first';\n    static readonly PLAY_SOUND_LAST = 'last';\n\n    static readonly CURRENT_SOUND = 'current';\n\n    static readonly PLAYER_MODE_AUDIO = 'player_mode_audio';\n    static readonly PLAYER_MODE_AJAX = 'player_mode_ajax';\n    static readonly PLAYER_MODE_FETCH = 'player_mode_fetch';\n\n    static readonly VISIBILITY_HIDDEN_ACTION_MUTE = 'visibility_hidden_action_mute';\n    static readonly VISIBILITY_HIDDEN_ACTION_PAUSE = 'visibility_hidden_action_pause';\n\n    constructor(playerOptions: ICoreOptions = {}) {\n\n        const defaultOptions: ICoreOptions = {\n            volume: 80,\n            loopQueue: false,\n            loopSong: false,\n            soundsBaseUrl: '',\n            playingProgressIntervalTime: 200,\n            playNextOnEnded: true,\n            stopOnReset: true,\n            visibilityWatch: false,\n            visibilityHiddenAction: VISIBILITY_HIDDEN_ACTION_PAUSE,\n            unlockAudioOnFirstUserInteraction: false,\n            persistVolume: true,\n            loadPlayerMode: PLAYER_MODE_AUDIO,\n            audioContext: null,\n            addAudioElementsToDom: false,\n            volumeTransitionTime: 100,\n        };\n\n        const options = Object.assign({}, defaultOptions, playerOptions);\n\n        this._queue = [];\n        this._currentIndex = 0;\n        this._options = options;\n        this._playingProgressPreviousTimestamp = 0;\n\n        this._initialize();\n\n    }\n\n    protected _initialize(): void {\n\n        const audioOptions = this._audioOptions();\n\n        this._playerAudio = new PlayerAudio(audioOptions);\n\n        switch (this._options.loadPlayerMode) {\n            case PlayerCore.PLAYER_MODE_AUDIO:\n                if (!this._playerAudio.detectAudioContextSupport()) {\n                    throw new Error('audio context is not supported by this device');\n                }\n                if (!this._playerAudio.detectAudioElementSupport()) {\n                    throw new Error('audio element is not supported by this device');\n                }\n                break;\n            case PlayerCore.PLAYER_MODE_AJAX:\n                if (!this._playerAudio.detectAudioContextSupport()) {\n                    throw new Error('audio context is not supported by this device');\n                }\n                break;\n        }\n\n    }\n\n    protected _audioOptions(): IAudioOptions {\n\n        const audioOptions: IAudioOptions = {\n            audioContext: this._options.audioContext,\n            unlockAudioOnFirstUserInteraction: this._options.unlockAudioOnFirstUserInteraction,\n            volume: this._options.volume,\n            persistVolume: this._options.persistVolume,\n            loadPlayerMode: this._options.loadPlayerMode,\n            addAudioElementsToDom: this._options.addAudioElementsToDom,\n            volumeTransitionTime: this._options.volumeTransitionTime,\n        };\n\n        return audioOptions;\n\n    }\n\n    public addSoundToQueue({ soundAttributes, whereInQueue = WHERE_IN_QUEUE_AT_END }: ISoundsQueueOptions): ISound {\n\n        const sound: ISound = new PlayerSound(soundAttributes);\n\n        switch (whereInQueue) {\n            case PlayerCore.WHERE_IN_QUEUE_AT_END:\n                this._appendSoundToQueue(sound);\n                break;\n            case PlayerCore.WHERE_IN_QUEUE_AT_START:\n                this._prependSoundToQueue(sound);\n                break;\n        }\n\n        return sound;\n\n    }\n\n    protected _appendSoundToQueue(sound: ISound): void {\n\n        this._queue.push(sound);\n\n    }\n\n    protected _prependSoundToQueue(sound: ISound): void {\n\n        this._queue.unshift(sound);\n\n    }\n\n    public async resetQueue(): Promise<void> {\n\n        if (this._options.stopOnReset) {\n            await this.stop();\n        }\n\n        this._queue.forEach((sound) => {\n            this._playerAudio.disconnectSound(sound);\n        });\n\n        this._queue = [];\n\n    }\n\n    public reset(): void {\n\n        this.resetQueue().catch((error) => {\n            console.error(error);\n        });\n\n    }\n\n    public getQueue(): ISound[] {\n\n        return this._queue;\n\n    }\n\n    public setVolume(volume: number): void {\n\n        this._playerAudio.setVolume(volume).catch((error) => {\n            console.error(error);\n        })\n\n    }\n\n    public getVolume(): number {\n\n        return this._playerAudio.getVolume();\n\n    }\n\n    public setLoopQueue(loppQueue: boolean): void {\n\n        this._options.loopQueue = loppQueue;\n\n    }\n\n    public getLoopQueue(): boolean {\n\n        return this._options.loopQueue;\n\n    }\n\n    public mute(): void {\n\n        const currentVolume = this.getVolume();\n\n        this._playerAudio.setVolume(0, false).catch((error) => {\n            console.error(error);\n        })\n\n        this._postMuteVolume = currentVolume;\n\n    }\n\n    public unMute(): void {\n\n        this._playerAudio.setVolume(this._postMuteVolume, false).catch((error) => {\n            console.error(error);\n        })\n\n        this._postMuteVolume = null;\n\n    }\n\n    public isMuted(): boolean {\n\n        return this._postMuteVolume === null ? false : true;\n\n    }\n\n    public async setPosition(soundPositionInPercent: number): Promise<void> {\n\n        if (soundPositionInPercent < 0 || soundPositionInPercent > 100) {\n            throw new Error('soundPositionInPercent must be a number >= 0 and <= 100');\n        }\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        if (currentSound !== null) {\n\n            currentSound.seekPercentage = Math.round(soundPositionInPercent);\n\n            const duration = currentSound.getDuration();\n\n            // if the duration did not get set manually or is not a number\n            if (duration === null || isNaN(duration)) {\n\n                // the user can set the sound duration manually but if he didn't the sound\n                // needs to get loaded first, to be able to know the duration it has\n                await this.loadSound(currentSound, PlayerCore.AFTER_LOADING_SEEK);\n\n            } else {\n\n                this._setPosition(currentSound);\n\n            }\n\n        }\n\n    }\n\n    protected _setPosition(sound: ISound): void {\n\n        const duration = sound.getDuration();\n\n        // calculate the position in seconds\n        const soundPositionInSeconds = (duration / 100) * sound.seekPercentage;\n\n        this.setPositionInSeconds(soundPositionInSeconds, sound);\n\n    }\n\n    public async setPositionInSeconds(soundPositionInSeconds: number, sound?: ISound): Promise<void> {\n\n        let currentSound: ISound = null;\n\n        if (typeof sound !== 'undefined') {\n            currentSound = sound;\n        } else {\n            currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n        }\n\n        if (currentSound !== null) {\n\n            // if the given position > duration, set position to duration\n            if (!isNaN(currentSound.duration) && (soundPositionInSeconds >= currentSound.duration)) {\n                // duration - 0.1 because in safari if currentTime = duration\n                // the onended event does not get triggered\n                soundPositionInSeconds = currentSound.duration - 0.1\n            }\n\n            const previousState = currentSound.state;\n\n            currentSound.state = PlayerSound.SOUND_STATE_SEEKING;\n\n            if (currentSound.onSeeking !== null) {\n\n                const playTime = soundPositionInSeconds;\n                const duration = currentSound.getDuration();\n                const seekingPercentageRaw = (playTime / duration) * 100;\n                const seekingPercentage = Math.round(seekingPercentageRaw);\n\n                currentSound.onSeeking(seekingPercentage, duration, playTime);\n\n            }\n\n            if (previousState === PlayerSound.SOUND_STATE_PLAYING) {\n\n                // already playing so just change the position\n                currentSound.playTime = soundPositionInSeconds;\n\n                if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AJAX) {\n                    // in ajax mode (when source is AudioBufferSourceNode) we\n                    // need to stop the song and start again at new position\n                    currentSound.elapsedPlayTime = soundPositionInSeconds;\n                    await this._stop(currentSound);\n                } else if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AUDIO) {\n                    // in audio (element) mode it is easier we can just change the position\n                    await this._play(currentSound);\n                }\n\n            } else {\n\n                // setPositionInSeconds got called and sound is currently not playing\n                // only set the sound position but don't play\n                currentSound.playTime = soundPositionInSeconds;\n\n            }\n\n        }\n\n    }\n\n    public async loadSound(sound: ISound, afterLoadingAction?: typeAfterLoadingAction): Promise<ISound> {\n\n        switch (this._options.loadPlayerMode) {\n            case PlayerCore.PLAYER_MODE_AUDIO:\n                await this._loadSoundUsingAudioElement(sound, afterLoadingAction);\n                break;\n            case PlayerCore.PLAYER_MODE_AJAX:\n                await this._loadSoundUsingRequest(sound, afterLoadingAction);\n                break;\n            case PlayerCore.PLAYER_MODE_FETCH:\n                // TODO: implement fetch (?)\n                console.warn(PlayerCore.PLAYER_MODE_FETCH + ' is not implemented yet');\n                break;\n        }\n\n        return sound;\n\n    }\n\n    protected async _loadSoundUsingAudioElement(sound: ISound, afterLoadingAction?: typeAfterLoadingAction): Promise<void> {\n\n        // extract the url and codec from sources\n        const { url, codec = null } = this._findBestSource(sound.source);\n\n        sound.url = url;\n        sound.codec = codec;\n\n        if (sound.url !== null) {\n\n            sound.audioElement = await this._playerAudio.getAudioElement();\n\n            // loading progress\n            // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/progress_event\n            sound.audioElement.onprogress = () => {\n\n                if (sound.audioElement.buffered.length) {\n\n                    let loadingPercentage: number;\n\n                    const buffered = sound.audioElement.buffered.end(0);\n                    const duration = sound.getDuration();\n\n                    if (typeof duration !== 'undefined') {\n                        const loadingPercentageRaw = 100 / (duration / buffered);\n                        loadingPercentage = Math.round(loadingPercentageRaw);\n                    }\n\n                    sound.loadingProgress = loadingPercentage;\n\n                    if (sound.onLoading !== null) {\n                        sound.onLoading(loadingPercentage, duration, buffered);\n                    }\n\n                    if (loadingPercentage === 100) {\n                        sound.isBuffering = false;\n                        sound.isBuffered = true;\n                        sound.audioBufferDate = new Date();\n                    }\n\n                }\n\n            }\n\n            const canPlayThroughHandler = async () => {\n\n                // we don't need the listener anymore\n                sound.audioElement.removeEventListener('canplaythrough', canPlayThroughHandler);\n                sound.isReadyToPLay = true;\n                // duration should now be available\n                // if it got set manually don't overwrite it\n                if (!isNaN(sound.audioElement.duration) && !sound.durationSetManually) {\n                    sound.duration = sound.audioElement.duration;\n                }\n\n                switch (afterLoadingAction) {\n                    case PlayerCore.AFTER_LOADING_SEEK:\n                        this._setPosition(sound)\n                        break;\n                    case PlayerCore.AFTER_LOADING_PLAY:\n                        this._play(sound);\n                        break;\n                }\n                \n            }\n\n            sound.audioElement.addEventListener('canplaythrough', canPlayThroughHandler);\n\n            // in chrome you will get this error message in the console:\n            // \"MediaElementAudioSource outputs zeroes due to CORS access restrictions\"\n            // to fix this put crossOrigin to anonymous or change the cors\n            // Access-Control-Allow-Origin header of the server to *\n            // \"crossOrigin\" has to be set before \"src\"\n            sound.audioElement.crossOrigin = 'anonymous';\n\n            sound.audioElement.src = sound.url;\n\n            // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/load\n            sound.audioElement.load();\n\n        } else {\n\n            //reject(new Error('sound has no url'));\n            throw new Error('sound has no url');\n\n        }\n\n    }\n\n    protected async _loadSoundUsingRequest(sound: ISound, afterLoadingAction?: typeAfterLoadingAction): Promise<void> {\n\n        // check for audio buffer before array buffer, because if one exist the other\n        // should exist too and is better for performance to reuse audio buffer then\n        // to redecode array buffer into an audio buffer\n        // user provided audio buffer\n        // decoding an array buffer is an expensive task even on modern hardware\n        // TODO: commented out for now, there is a weird bug when reusing the\n        // audio buffer, somehow the onended callback gets triggered in a loop\n        /*if (sound.audioBuffer !== null) {\n            return;\n        }*/\n\n        // user provided array buffer\n        if (sound.arrayBuffer !== null) {\n            return await this._decodeSound(sound);\n        }\n\n        // extract the url and codec from sources\n        const { url, codec = null } = this._findBestSource(sound.source);\n\n        sound.url = url;\n        sound.codec = codec;\n\n        if (sound.url !== null) {\n\n            const request = new PlayerRequest();\n\n            sound.isBuffering = true;\n            const arrayBuffer = await request.getArrayBuffer(sound);\n            sound.arrayBuffer = arrayBuffer;\n\n            await this._decodeSound(sound, afterLoadingAction);\n\n        } else {\n\n            throw new Error('sound has no url');\n\n        }\n\n    }\n\n    protected async _decodeSound(sound: ISound, afterLoadingAction?: typeAfterLoadingAction): Promise<void> {\n\n        // make a copy of the array buffer first\n        // because the decoding will detach the array buffer\n        // https://github.com/WebAudio/web-audio-api/issues/1175\n        const arrayBufferCopy = sound.arrayBuffer.slice(0);\n\n        const audioBuffer = await this._playerAudio.decodeAudio(arrayBufferCopy);\n\n        // duration should now be available\n        // if it got set manually don't overwrite it\n        if (!isNaN(audioBuffer.duration) && !sound.durationSetManually) {\n            sound.duration = audioBuffer.duration;\n        }\n\n        sound.audioBuffer = audioBuffer;\n        sound.isBuffering = false;\n        sound.isBuffered = true;\n        sound.audioBufferDate = new Date();\n        sound.isReadyToPLay = true;\n\n        switch (afterLoadingAction) {\n            case PlayerCore.AFTER_LOADING_SEEK:\n                this._setPosition(sound)\n                break;\n            case PlayerCore.AFTER_LOADING_PLAY:\n                this._play(sound);\n                break;\n        }\n\n    }\n\n    public async play({ whichSound, playTimeOffset }: IPlayOptions = {}): Promise<ISound> {\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        // whichSound is optional, if set it can be the sound id (string or number)\n        // or it can be these 4 constants: PLAY_SOUND_NEXT, PLAY_SOUND_PREVIOUS,\n        // PLAY_SOUND_FIRST, PLAY_SOUND_LAST\n        const sound = this._getSoundFromQueue({ whichSound, updateIndex: true });\n\n        // if there is no sound we could play, do nothing\n        if (sound === null) {\n            return sound;\n        }\n\n        // if there is a sound currently being played\n        // AND the current sound is the same sound as the one that will now be played\n        if (\n            currentSound !== null\n            && (currentSound.state === PlayerSound.SOUND_STATE_PLAYING)\n            && (currentSound.id === sound.id)\n        ) {\n            if (!isNaN(playTimeOffset)) {\n                // sound is already playing but a playTimeOffset got set\n                // so we just need to seek\n                this.setPositionInSeconds(playTimeOffset);\n                return sound;\n            } else {\n                // sound is already playing, do nothing\n                return sound;\n            }\n        }\n\n        // if there is a sound currently being played OR paused\n        // AND the current sound is NOT the same sound as the one that will now be played\n        if (\n            currentSound !== null\n            && (currentSound.state === PlayerSound.SOUND_STATE_PLAYING || currentSound.state === PlayerSound.SOUND_STATE_PAUSED)\n            && (currentSound.id !== sound.id)\n        ) {\n            // stop the current sound\n            currentSound.state = PlayerSound.SOUND_STATE_STOPPED;\n            await this._stop(currentSound);\n        }\n\n        // if the user wants to play the sound from a certain position\n        // then playTimeOffset should be a number and not undefined\n        if (!isNaN(playTimeOffset)) {\n            sound.playTimeOffset = playTimeOffset;\n        } else {\n            sound.playTimeOffset = 0;\n        }\n\n        if (sound.sourceNode === null) {\n            // connect the source to the gain (graph) node\n            await this._playerAudio.connectSound(sound, () => {\n                this._onEnded();\n            });\n        }\n\n        if (!sound.isReadyToPLay) {\n\n            await this.loadSound(sound, PlayerCore.AFTER_LOADING_PLAY);\n\n        } else {\n\n            await this._play(sound);\n\n        }\n\n        return sound;\n\n    }\n\n    protected async _play(sound: ISound): Promise<void> {\n\n        if (sound.state === PlayerSound.SOUND_STATE_PLAYING) {\n            return;\n        }\n\n        if (this._playerAudio.isAudioContextFrozen()) {\n            await this._playerAudio.unfreezeAudioContext();\n        }\n\n        if (sound.playTimeOffset > 0) {\n            sound.playTime = sound.playTimeOffset;\n        }\n\n        if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AJAX) {\n            await this._playAudioBuffer(sound);\n        } else if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AUDIO) {\n            await this._playMediaElementAudio(sound);\n        }\n\n        // the AudioBufferSourceNode does not have events (other than onended)\n        // the playbackState got removed:\n        // https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Migrating_from_webkitAudioContext#changes_to_determining_playback_state\n        // for the AudioElement we could use the play event to trigger the next two lines!?\n        // https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement#events\n        sound.state = PlayerSound.SOUND_STATE_PLAYING;\n\n        this._triggerSoundCallbacks(sound);\n\n    }\n\n    protected async _playAudioBuffer(sound: ISound): Promise<void> {\n\n        // AudioBufferSourceNode type guard\n        if (sound.sourceNode instanceof AudioBufferSourceNode) {\n\n            // on play, seek, pause, always reset the sound startTime (current context time)\n            sound.startTime = sound.sourceNode.context.currentTime;\n\n            // add the audio buffer to the source node\n            sound.sourceNode.buffer = sound.audioBuffer;\n\n            // start playback\n            // start(when, offset, duration)\n            try {\n                if (sound.state === PlayerSound.SOUND_STATE_SEEKING) {\n                    sound.sourceNode.start(0, sound.playTime);\n                } else if (sound.state === PlayerSound.SOUND_STATE_PAUSED && sound.playTimeOffset === 0) {\n                    sound.sourceNode.start(0, sound.playTime);\n                } else {\n                    if (sound.playTimeOffset > 0) {\n                        // round duration up as numbers are not integers\n                        // so sometimes it is a tiny bit above\n                        if (sound.playTimeOffset > Math.ceil(sound.duration)) {\n                            console.warn('playTimeOffset > sound duration');\n                        }\n                        // if an offset is defined start playing at that position\n                        sound.elapsedPlayTime = sound.playTimeOffset;\n                        sound.sourceNode.start(0, sound.playTimeOffset);\n                    } else {\n                        sound.sourceNode.start();\n                    }\n                }\n\n            } catch (error) {\n                throw new Error(error);\n            }\n        }\n\n    }\n\n    protected async _playMediaElementAudio(sound: ISound): Promise<void> {\n\n        // MediaElementAudioSourceNode type guard\n        if (sound.sourceNode instanceof MediaElementAudioSourceNode) {\n\n            if (sound.state === PlayerSound.SOUND_STATE_SEEKING) {\n                sound.audioElement.currentTime = sound.playTime;\n            } else if (sound.state === PlayerSound.SOUND_STATE_PAUSED && sound.playTimeOffset === 0) {\n                sound.audioElement.currentTime = sound.playTime;\n            } else {\n                // if an offset is defined start playing at that position\n                if (sound.playTimeOffset > 0) {\n                    // round duration up as numbers are not integers\n                    // so sometimes it is a tiny bit above\n                    if (sound.playTimeOffset > Math.ceil(sound.duration)) {\n                        console.warn('playTimeOffset > duration');\n                    }\n                    sound.audioElement.currentTime = sound.playTimeOffset;\n                } else {\n                    sound.audioElement.currentTime = 0;\n                }\n            }\n\n            return await sound.audioElement.play();\n\n        }\n\n    }\n\n    protected _triggerSoundCallbacks(sound: ISound) {\n\n        if (sound.onResumed !== null && !sound.firstTimePlayed) {\n            sound.onResumed(sound.playTime);\n        }\n\n        if (sound.onStarted !== null && sound.firstTimePlayed) {\n            sound.firstTimePlayed = false;\n            sound.onStarted(sound.playTimeOffset);\n        }\n\n        if (sound.onPlaying !== null) {\n            // reset progress timestamp\n            this._playingProgressPreviousTimestamp = 0;\n            // \"request animation frame\" callback has an argument, which\n            // is the timestamp when the callback gets called\n            // as this is the first call set timestamp manually to zero\n            this._progressTrigger(sound, 0);\n        } else {\n            this._playingProgressRequestId = null;\n        }\n\n        return;\n\n    }\n\n    protected _progressTrigger = (sound: ISound, timestamp: DOMHighResTimeStamp) => {\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        // I had a lot of trouble cancelling the animation frame\n        // this is why I added this check\n        // often onended would get called by even though I do\n        // a cancel in _stop() the animation frame would still repeat\n        if (sound.id !== currentSound.id || currentSound.state !== PlayerSound.SOUND_STATE_PLAYING) {\n            return;\n        }\n\n        // throttle requests, use time set in options and\n        // make sure that at least that amount is elapsed \n        if ((timestamp - this._playingProgressPreviousTimestamp) >= this._options.playingProgressIntervalTime) {\n\n            const currentTime = sound.getCurrentTime();\n            const duration = sound.getDuration();\n\n            if (!isNaN(currentTime) && !isNaN(duration)) {\n\n                let playingPercentage = 0;\n\n                if (currentTime !== 0) {\n                    const playingPercentageRaw = (currentTime / duration) * 100;\n                    playingPercentage = Math.round(playingPercentageRaw);\n                }\n\n                sound.playedTimePercentage = playingPercentage;\n                sound.playTime = currentTime;\n\n                // execute playing progress callback\n                sound.onPlaying(playingPercentage, duration, currentTime);\n\n                this._playingProgressPreviousTimestamp = timestamp;\n            }\n\n        }\n\n        // request animation frame loop\n        this._playingProgressRequestId = window.requestAnimationFrame((timestamp) => {\n            this._progressTrigger(sound, timestamp);\n        });\n\n    }\n\n    protected async _onEnded(): Promise<void> {\n\n        if (this._options.playNextOnEnded) {\n\n            const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n            if (currentSound !== null) {\n\n                // when we set the sound to paused...\n                // audio buffer will trigger onEnded because we actually stop the song\n                // audio element will not trigger onEnded as we pause the song\n                // this is why, for audio buffer (ajax) sounds we check if they have\n                // the playing state before triggering the next sound\n                // if stopped, seeking or pause we do nothing\n                if (\n                    this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AUDIO ||\n                    (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AJAX && currentSound.state === PlayerSound.SOUND_STATE_PLAYING)\n                ) {\n\n                    const nextSound = this._getSoundFromQueue({ whichSound: PlayerCore.PLAY_SOUND_NEXT });\n\n                    let willPlayNext = false;\n\n                    // check if there is another sound in the queue\n                    if (nextSound !== null) {\n                        willPlayNext = true;\n                    }\n\n                    if (!willPlayNext) {\n                        await this._playerAudio.freezeAudioContext();\n                    }\n\n                    if (currentSound.onEnded !== null) {\n                        currentSound.onEnded(willPlayNext);\n                    }\n\n                    try {\n                        if (willPlayNext) {\n                            await this.next();\n                        }\n                    } catch (error) {\n                        console.error(error)\n                    }\n\n                }\n\n                if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AJAX && currentSound.state === PlayerSound.SOUND_STATE_SEEKING) {\n                    try {\n                        // audio buffer source nodes get destroyed on stop\n                        // this is why in ajax mode we need to do a fresh start when seeking\n                        await this.play(currentSound);\n                    } catch (error) {\n                        console.error(error)\n                    }\n                }\n\n            }\n\n        }\n\n    }\n\n    protected _getSoundFromQueue({ whichSound, updateIndex = false }: IGetSoundFromQueue = {}): ISound {\n\n        let sound = null;\n        let soundIndex: number = null;\n\n        // check if the queue is empty\n        if (this._queue.length === 0) {\n            return sound;\n        }\n\n        // if which sound to play did not get specified\n        // we set it to the current sound by default\n        if (typeof whichSound === 'undefined') {\n            whichSound = PlayerCore.CURRENT_SOUND;\n        }\n\n        switch (whichSound) {\n            case PlayerCore.CURRENT_SOUND:\n                soundIndex = this._currentIndex\n                sound = this._queue[soundIndex];\n                break;\n            case PlayerCore.PLAY_SOUND_NEXT:\n                if (this._queue[this._currentIndex + 1] !== undefined) {\n                    soundIndex = this._currentIndex + 1;\n                    sound = this._queue[soundIndex];\n                } else if (this._options.loopQueue) {\n                    // if last sound is playing and loop queue is enabled\n                    // then on onEnded we go from last to first sound\n                    soundIndex = 0;\n                    sound = this._queue[soundIndex];\n                }\n                break;\n            case PlayerCore.PLAY_SOUND_PREVIOUS:\n                if (this._queue[this._currentIndex - 1] !== undefined) {\n                    soundIndex = this._currentIndex - 1;\n                    sound = this._queue[soundIndex];\n                } else if (this._options.loopQueue) {\n                    // if first sound of the queue is playing and loop queue is enabled\n                    // then if previous() gets used, we jump to last sound in queue\n                    soundIndex = this._queue.length - 1;\n                    sound = this._queue[soundIndex];\n                }\n                break;\n            case PlayerCore.PLAY_SOUND_FIRST:\n                if (this._queue.length > 0) {\n                    soundIndex = 0;\n                    sound = this._queue[soundIndex];\n                }\n                break;\n            case PlayerCore.PLAY_SOUND_LAST:\n                if (this._queue.length > 0) {\n                    soundIndex = this._queue.length - 1;\n                    sound = this._queue[soundIndex];\n                }\n                break;\n            default:\n                // if \"which sound to play\" is a soundId\n                // Note: soundId can be a string or number\n                [sound, soundIndex] = this._findSoundById({ soundId: whichSound });\n        }\n\n        if (soundIndex !== null && updateIndex) {\n            this._currentIndex = soundIndex;\n        }\n\n        return sound;\n\n    }\n\n    protected _findSoundById({ soundId }: IFindSoundById): [ISound, number] {\n\n        let sound: ISound = null;\n        let soundIndex = 0;\n\n        this._queue.some((soundFromQueue, index) => {\n\n            if (soundFromQueue.id === soundId) {\n                sound = soundFromQueue;\n                soundIndex = index;\n                return true;\n            }\n\n        });\n\n        return [sound, soundIndex];\n\n    }\n\n    protected _findBestSource(soundSource: (ISoundSource)[] | ISoundSource): IFindBestSourceResponse {\n\n        const bestSource: IBestSource = {\n            url: null,\n            codec: null\n        };\n\n        let sources: (ISoundSource)[];\n\n        // if the source is not an array but a single source object\n        // we first transform it into an array\n        if (!Array.isArray(soundSource)) {\n            sources = [soundSource];\n        } else {\n            sources = soundSource;\n        }\n\n        let i = 0;\n\n        while (i < sources.length) {\n\n            const source = sources[i]\n            let soundUrl = '';\n\n            // if the player has set the baseUrl option for sounds, use it now\n            if (this._options.soundsBaseUrl !== '') {\n                soundUrl = this._options.soundsBaseUrl;\n            }\n\n            soundUrl += source.url;\n\n            // check if the codec (if any got specified) is supported\n            // by the device\n            let isCodecSupported = true;\n\n            if (source.codec !== null) {\n                isCodecSupported = this._checkCodecSupport(source.codec);\n            }\n\n            if (isCodecSupported) {\n\n                if (source.isPreferred) {\n                    // if multiple sources but this one if preferred and if previous\n                    // sources also had a supported codec we still overwrite the\n                    // previous match\n                    bestSource.url = soundUrl;\n                    bestSource.codec = source.codec;\n                    // as the source is marked as preferred and it is supported\n                    // so we can exit early\n                    break;\n                } else {\n                    // if no best source has been found so far, we don't\n                    // care if it's preferred it's automatically chosen\n                    // as being the best\n                    bestSource.url = soundUrl;\n                    bestSource.codec = source.codec;\n                    // source is supported, but maybe there is preferred & supported\n                    // so we don't exit the loop just yet and continue searching\n                }\n\n            }\n\n            i++;\n\n        }\n\n        return bestSource;\n\n    }\n\n    protected _checkCodecSupport(codec: string): boolean {\n\n        let mediaMimeTypes: string[];\n        let error = '';\n\n        switch (codec) {\n            case 'ogg':\n                mediaMimeTypes = ['audio/ogg; codecs=\"vorbis\"'];\n                break;\n            case 'oga':\n                mediaMimeTypes = ['audio/ogg; codecs=\"vorbis\"'];\n                break;\n            case 'mp3':\n                mediaMimeTypes = ['audio/mpeg; codecs=\"mp3\"'];\n                break;\n            case 'opus':\n                mediaMimeTypes = ['audio/ogg; codecs=\"opus\"', 'audio/webm; codecs=\"opus\"'];\n                break;\n            case 'wav':\n                mediaMimeTypes = ['audio/wav; codecs=\"1\"'];\n                break;\n            case 'm4a':\n                mediaMimeTypes = ['audio/m4a;', 'audio/x-m4a;'];\n                break;\n            case 'm4p':\n                mediaMimeTypes = ['audio/m4p;', 'audio/x-m4p;'];\n                break;\n            case 'caf':\n                mediaMimeTypes = ['audio/x-caf;'];\n                break;\n            case 'aac':\n                mediaMimeTypes = ['audio/aac;'];\n                break;\n            case 'weba':\n            case 'webm':\n                mediaMimeTypes = ['audio/webm; codecs=\"vorbis\"'];\n                break;\n            case 'flac':\n                mediaMimeTypes = ['audio/flac;', 'audio/x-flac;'];\n                break;\n            default:\n                error = 'unrecognised codec';\n                break;\n        }\n\n        if (error) {\n            throw new Error(error);\n        }\n\n        return this._checkMimeTypesSupport(mediaMimeTypes);\n\n    }\n\n    protected _checkMimeTypesSupport(mediaMimeTypes: string[]): boolean {\n\n        const deviceAudio = new Audio();\n\n        let isSupported = false;\n\n        mediaMimeTypes.forEach((mediaMimeType) => {\n\n            const isMediaTypeSupported: string = deviceAudio.canPlayType(mediaMimeType).replace(/^no$/, '');\n\n            if (isMediaTypeSupported) {\n                isSupported = true;\n            }\n\n        });\n\n        return isSupported;\n\n    }\n\n    public async pause(): Promise<ISound> {\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        if (currentSound === null) {\n            return;\n        }\n\n        if (currentSound.state === PlayerSound.SOUND_STATE_PAUSED) {\n            return;\n        }\n\n        const currentTime = currentSound.getCurrentTime();\n\n        currentSound.playTime = currentTime;\n\n        if (this._options.loadPlayerMode === PlayerCore.PLAYER_MODE_AJAX) {\n            currentSound.elapsedPlayTime = currentTime;\n        }\n\n        if (currentSound.onPaused !== null) {\n            currentSound.onPaused(currentSound.playTime);\n        }\n\n        currentSound.state = PlayerSound.SOUND_STATE_PAUSED;\n\n        await this._stop(currentSound);\n\n        return currentSound;\n\n    }\n\n    public async stop(): Promise<ISound> {\n\n        const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n        if (currentSound === null) {\n            return;\n        }\n\n        if (currentSound.state === PlayerSound.SOUND_STATE_STOPPED) {\n            return;\n        }\n\n        // on stop we freeze the audio context\n        // as we assume it won't be needed right away\n        await this._playerAudio.freezeAudioContext();\n\n        if (currentSound.onStopped !== null) {\n            currentSound.onStopped(currentSound.playTime);\n        }\n\n        currentSound.state = PlayerSound.SOUND_STATE_STOPPED;\n\n        await this._stop(currentSound);\n\n        return currentSound;\n\n    }\n\n    protected async _stop(sound: ISound): Promise<void> {\n\n        if (this._playingProgressRequestId !== null) {\n            cancelAnimationFrame(this._playingProgressRequestId);\n            this._playingProgressRequestId = null;\n        }\n\n        if (sound.sourceNode !== null) {\n\n            if (sound.sourceNode instanceof AudioBufferSourceNode) {\n                // if using the AudioBufferSourceNode use the stop method\n                sound.sourceNode.stop(0);\n                // the \"audio buffer\" CAN be reused for multiple plays\n                // however the \"audio buffer source\" CAN NOT, so we disconnect\n                await this._playerAudio.disconnectSound(sound);\n            }\n\n            if (sound.sourceNode instanceof MediaElementAudioSourceNode) {\n                // if using the MediaElementAudioSourceNode use the pause method\n                sound.audioElement.pause();\n            }\n\n        }\n\n        // if it is fully stopped, not just paused (or seeking)\n        if (sound.state === PlayerSound.SOUND_STATE_STOPPED) {\n            // reset sound values\n            sound.isReadyToPLay = false;\n            sound.firstTimePlayed = true;\n            sound.startTime = 0;\n            sound.elapsedPlayTime = 0;\n            sound.playTime = 0;\n            sound.playedTimePercentage = 0;\n            // disconnect the sound\n            await this._playerAudio.disconnectSound(sound);\n        }\n\n    }\n\n    public async next(): Promise<ISound> {\n\n        return await this.play({ whichSound: PlayerCore.PLAY_SOUND_NEXT });\n\n    }\n\n    public async previous(): Promise<ISound> {\n\n        return await this.play({ whichSound: PlayerCore.PLAY_SOUND_PREVIOUS });\n\n    }\n\n    public async first(): Promise<ISound> {\n\n        return await this.play({ whichSound: PlayerCore.PLAY_SOUND_FIRST });\n\n    }\n\n    public async last(): Promise<ISound> {\n\n        return await this.play({ whichSound: PlayerCore.PLAY_SOUND_LAST });\n\n    }\n\n    public setVisibilityWatch(visibilityWatch: boolean): void {\n\n        this._options.visibilityWatch = visibilityWatch;\n\n        if (visibilityWatch) {\n            document.addEventListener('visibilitychange', this._handleVisibilityChange.bind(this), false);\n        } else {\n            document.removeEventListener('visibilitychange', this._handleVisibilityChange.bind(this), false);\n        }\n\n    }\n\n    public getVisibilityWatch(): boolean {\n        return this._options.visibilityWatch;\n    }\n\n    public setVisibilityHiddenAction(visibilityHiddenAction: typeVisibilityHiddenAction): void {\n        this._options.visibilityHiddenAction = visibilityHiddenAction;\n    }\n\n    public getVisibilityHiddenAction(): typeVisibilityHiddenAction {\n        return this._options.visibilityHiddenAction;\n    }\n\n    protected _handleVisibilityChange(): void {\n\n        let hiddenKeyword: string;\n\n        if (typeof document.hidden !== 'undefined') {\n            // Opera 12.10 and Firefox 18 and later support\n            hiddenKeyword = 'hidden';\n\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof (document as any).msHidden !== 'undefined') {\n            hiddenKeyword = 'msHidden';\n\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof (document as any).webkitHidden !== 'undefined') {\n            hiddenKeyword = 'webkitHidden';\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if ((document as any)[hiddenKeyword]) {\n\n            if (this._options.visibilityHiddenAction === PlayerCore.VISIBILITY_HIDDEN_ACTION_PAUSE) {\n\n                const currentSound = this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n                if (currentSound === null) {\n                    return;\n                }\n        \n                if (currentSound.state === PlayerSound.SOUND_STATE_PLAYING) {\n                    this.pause();\n                    this._postVisibilityHiddenPlaying = true;\n                } else {\n                    this._postVisibilityHiddenPlaying = false;\n                }\n\n            } else if (this._options.visibilityHiddenAction === PlayerCore.VISIBILITY_HIDDEN_ACTION_MUTE) {\n                this.mute();\n            }\n        } else {\n            if (this._options.visibilityHiddenAction === PlayerCore.VISIBILITY_HIDDEN_ACTION_PAUSE && this._postVisibilityHiddenPlaying === true) {\n                this.play();\n            } else if (this._options.visibilityHiddenAction === PlayerCore.VISIBILITY_HIDDEN_ACTION_MUTE) {\n                this.unMute();\n            }\n        }\n\n    }\n\n    public async manuallyUnlockAudio() {\n\n        await this._playerAudio.unlockAudio();\n\n    }\n\n    public async disconnect(): Promise<void> {\n\n        // adding another check here to cancel animation frame because:\n        // a player can be disconnect while song is paused or playing\n        // which means the cancelAnimationFrame in _stop would never get triggered\n        if (this._playingProgressRequestId !== null) {\n            cancelAnimationFrame(this._playingProgressRequestId);\n            this._playingProgressRequestId = null;\n        }\n\n        await this._playerAudio.shutDown(this._queue);\n\n    }\n\n    public async getAudioContext(): Promise<AudioContext> {\n\n        const audioContext = await this._playerAudio.getAudioContext();\n\n        return audioContext;\n\n    }\n\n    public getCurrentSound(): ISound {\n\n        return this._getSoundFromQueue({ whichSound: PlayerCore.CURRENT_SOUND });\n\n    }\n\n}\n"],"names":[],"mappings":"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"}